<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>php反射</title>
      <link href="/2020/02/18/php-fan-she/"/>
      <url>/2020/02/18/php-fan-she/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>PHP5 具有完整的反射 API，如Java中的java.lang.reflect包一样，有对类、接口、函数、方法和扩展进行反向工程的能力。在某些方面和对象函数相似，比如get_class_vars()。反射API也可与PHP最新的面向对象特性一起工作，如访问控制、接口和抽象类。</p></blockquote><h3 id="反射API的部分类"><a href="#反射API的部分类" class="headerlink" title="反射API的部分类"></a>反射API的部分类</h3><p>使用反射API这些类，可以获得在运行时访问对象、函数和脚本中的扩展的信息。</p><p>|<strong>类</strong>|<strong>描     述</strong>|<br>|Reflection|为类的摘要信息提供静态函数export()|<br>|ReflectionClass|类信息和工具|<br>|ReflectionMethod|类方法信息和工具|<br>|ReflectionParameter|方法参数信息|<br>|ReflectionProperty|类属性信息|<br>|ReflectionFunction|函数信息和工具|<br>|ReflectionExtension|PHP扩展信息|<br>|ReflectionException|错误类|</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>相信大家对php反射已经有一定的了解，在php主流框架中像是依赖注入、对象池、类加载等等，都有比较常见的应用。</p><p>这里，我们建一个基础的容器类：</p><pre><code>class Container{    public static function getInstance($class_name,$params = []){        //获取反射实例        $reflect = new ReflectionClass($class_name);        //获取反射实例的构造方法        $construct = $reflect-&gt;getConstruct();        //获取反射实例构造方法的形参        $di_params = [];        if($construct){            foreach($construct-&gt;getParams as $param){                $class = $param-&gt;getClass();                    // 如果参数是一个类，创建实例                    if ($class) {                         $di_params[] = new $class-&gt;name;                    }            }         }        $di_params = array_merge($di_params,$param);        //通过参数$di_params创建一个新的类实例。        return $reflect-&gt;newInstanceArgs($di_params);    }}</code></pre><p>这里获取构造方法参数是用了ReflectionClass类，具体其他相关类的适用可以参考<a href=""https://www.php.net/manual/zh/reflectionclass.newinstanceargs.php"">PHP官方手册-反射</a></p><h3 id="实现自动注入依赖"><a href="#实现自动注入依赖" class="headerlink" title="实现自动注入依赖"></a>实现自动注入依赖</h3><pre><code>class A{    protected $num = 10;    public function getNum(){        return $this-&gt;num;    }}class B{    protected $total;    public function __construct(A $obj,$num){        $this-&gt;total = $obj-&gt;getNum() + $num;    }    public function getTotal(){        return $this-&gt;total;    }}$b = Container::getInstance(B::class, [10]);var_dump($b-&gt;getCount()); // result is 20</code></pre><blockquote><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4></blockquote><p>上面代码虽然进行了注入，但是只有一层。如果A类也有注入呢？</p><pre><code>class Container{    public static function getInstance($class_name,$params = []){        //获取反射实例        $reflect = new ReflectionClass($class_name);        //获取反射实例的构造方法        $construct = $reflect-&gt;getConstruct();        //获取反射实例构造方法的形参        $di_params = [];        if($construct){            foreach($construct-&gt;getParams as $param){                $class = $param-&gt;getClass();                    // 如果参数是一个类，创建实例                    if ($class) {                         $di_params[] = self::getInstance($class-&gt;name);                    }            }         }        $di_params = array_merge($di_params,$param);        //通过参数$di_params创建一个新的类实例。        return $reflect-&gt;newInstanceArgs($di_params);    }}</code></pre><p>测试一下：</p><pre><code>class C{    public $num = 1;}class A{    protected $num = 10;    public function __construct(C $c){        $this-&gt;num = $this-&gt;num + $c-&gt;num;    }    public function getNum(){        return $this-&gt;num;    }}class B{    protected $total;    public function __construct(A $a,$num){        $this-&gt;total = $a-&gt;getNum() + $num;    }    public function getTotal(){        return $this-&gt;total;    }}$b = Container::getInstance(B::class, [10]);var_dump($b-&gt;getCount()); // result is 21</code></pre><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>有些类在程序的生命周期会频繁的使用，为了在依赖注入中避免经常性的创建实例，我们依靠单例模式的设计，使已经是依赖的对象可以被直接获取</p><pre><code>class Container{    protected staic $_singleton = [];    //增加一个实例到单例中    public static function singleton($instance){        if(!is_object($instance)){            throw new \Exception(&quot;not object type&quot;);        }        $class_name = get_class($instance);         // 添加到单例中        if ( ! array_key_exists($class_name, self::$_singleton)) {            self::$_singleton[$class_name] = $instance;        }    }    //从单例中获取实例    public static function getSingleton($class_name){        return isset(self::$_singleton[$class_name]) ? self::$_singleton[$class_name] : [];    }    //销毁实例    public static function delSingleton($class_name){        unset(self::$_singleton[$class_name]);    }}</code></pre><p>改造：</p><pre><code>class Container{    protected staic $_singleton = [];    //增加一个实例到单例中    public static function singleton($instance){        if(!is_object($instance)){            throw new \Exception(&quot;not object type&quot;);        }        $class_name = get_class($instance);         // 添加到单例中        if ( ! array_key_exists($class_name, self::$_singleton)) {            self::$_singleton[$class_name] = $instance;        }    }    //从单例中获取实例    public static function getSingleton($class_name){        return isset(self::$_singleton[$class_name]) ? self::$_singleton[$class_name] : [];    }    //销毁实例    public static function delSingleton($class_name){        unset(self::$_singleton[$class_name]);    }    /**    *    */    public static function getInstance($class_name,$params = []){        //获取反射实例        $reflect = new ReflectionClass($class_name);        //获取反射实例的构造方法        $construct = $reflect-&gt;getConstruct();        //获取反射实例构造方法的形参        $di_params = [];        if($construct){            foreach($construct-&gt;getParams as $param){                $class = $param-&gt;getClass();                    // 如果参数是一个类，创建实例                    if ($class) {                         //单例实例是否存在                        $singleton = self::$getSingleton();                        $di_params[] = $singleton ?? self::getInstance($class-&gt;name);                    }            }         }        $di_params = array_merge($di_params,$param);        //通过参数$di_params创建一个新的类实例。        return $reflect-&gt;newInstanceArgs($di_params);    }}</code></pre><h3 id="以依赖注入的方式运行方法"><a href="#以依赖注入的方式运行方法" class="headerlink" title="以依赖注入的方式运行方法"></a>以依赖注入的方式运行方法</h3><p>由于调用的类和函数是未知的，这里利用回调调用函数及反射满足此功能</p><pre><code>class Container{    public static function run($class_name,$method_name,$params=[],$construct_params = []){        if(!class_exists($class_name)){            throw new \Exception(&quot;$class_name class not fund&quot;);        }        if(!method_exists($class_name,$method_name)){            throw new \Exception(&quot;$method_name not fund in $class_name&quot;);        }        //获取实例        $instance = self::getInstance($class_name,$construct_params);         // 获取反射实例        $reflect = new ReflectionClass($class_name);        // 获取方法        $reflectMethod = $reflect-&gt;getMethod($method_name);        //查找方法的参数        $di_params = [];        foreach($reflectMethod-&gt;getParameters as $param){            $class = $param-&gt;getClass();            if ($class) {                 $singleton = self::getSingleton($class);                $di_params[] = $singleton ?? self::getInstance($class-&gt;name);            }        }        // 运行方法        return call_user_func_array([$instance, $method_name], array_merge($di_params, $params));    }}</code></pre><p>测试一下：</p><pre><code>class A{    protected $num = 10;    public function getNum(){        return $this-&gt;num;    }}class B{    protected $total;    public function __construct(A $obj,$num){        $this-&gt;total = $obj-&gt;getNum() + $num;    }    public function getTotal(){        return $this-&gt;total;    }}Container::run(B::class, &#39;getTotal&#39; ,[10]);// result is 20</code></pre><p>这里完整的代码可以转移[github](“ <a href="https://github.com/DamonNie/IocContainer.git&quot;" target="_blank" rel="noopener">https://github.com/DamonNie/IocContainer.git&quot;</a>)</p><p>此处特感谢<a href=""https://github.com/wazsmwazsm/IOCContainer/"">@wazsmwazsm</a>、<a href=""https://www.cnblogs.com/bndong/p/7988365.html"">@BNDong</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>死磕设计模式-依赖注入和控制反转</title>
      <link href="/2020/01/12/si-ke-she-ji-mo-shi-yi-lai-zhu-ru-he-kong-zhi-fan-zhuan/"/>
      <url>/2020/01/12/si-ke-she-ji-mo-shi-yi-lai-zhu-ru-he-kong-zhi-fan-zhuan/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC容器-Laravel的核心"><a href="#IOC容器-Laravel的核心" class="headerlink" title="IOC容器-Laravel的核心"></a>IOC容器-Laravel的核心</h2><p>初学Laravel的时候，经常有看到类作为变量参数传入第三方类的方法函数中，这就是依赖。我们这里就来讲讲Laravel的核心-Ioc，Laravel文档中称之为”服务容器”。顾名思义，该容器提供了整个框架中需要的一系列服务。</p><h3 id="依赖的产生"><a href="#依赖的产生" class="headerlink" title="依赖的产生"></a>依赖的产生</h3><p>面对对象编程中，无时不刻不贯穿有以下几样东西：接口、类和对象。其中，接口是类的原型；一个类必须遵守其实现的接口；对象则是类实例化后的产物，我们称之为一个实例。接下来，我们就以实际生活为示例讲解。</p><blockquote><p>平时工作生活中需要使用的电脑<br>这里，我们把电脑作为一个类<br><code>class Computer{}</code><br>可以联想到，单独的电脑还有接口设备才算意义上的完整。这里，我们定义键盘作为一个类(为了省事儿我没有详细写出 __construct() 这个构造函数的全部，只写了需要传递的参数)</p></blockquote><pre><code>class Keyboard{    //名称 string    protected $name;    //品牌 string    protected $brand;    public function __construct($name,$brand){        $this-&gt;name = $name;        $this-&gt;brand = $brand;    }}</code></pre><p>回过头，我们重新构造Computer类</p><pre><code>class Computer{    protected $equipment;    public function __construct(){        $this-&gt;equipment = new Keyboard(&#39;my&#39;, &#39;罗技&#39;);    }}</code></pre><p>可以看到只要实例化Computer类的同时，也是创建一个Keyboard的实例，这里，”Computer”和”Keyboard”类不可避免产生依赖的关系。</p><p>在一个贯彻面向对象编程的项目，这种依赖随处可见。少量的依赖并不会有太过直观的影响。随着例子逐渐展开，我们会意识到，当依赖到达一个量级的时候，是怎样一种噩梦的体验。</p><h3 id="可怕的依赖"><a href="#可怕的依赖" class="headerlink" title="可怕的依赖"></a>可怕的依赖</h3><p>我们都知道，电脑的硬件组成部分还很多，这里我们给电脑丰富一下硬件条件：</p><ul><li><p>显示屏，属性有尺寸、分辨率</p></li><li><p>鼠标，属性有有线无线、接口方式</p></li><li><p>风扇，属性有功率、转速</p><pre><code>class Screen{  protected $size;  protected $resolution;  public function __construct($size,$resolution){      //pending  }}class Mouse{  protected $line;  protected $interface_type;  public function __construct($line,$interface_typr){      //pending  }}class Fan{  protected $power;  protected $speed;  public function __construct($power,$speed){      //pending  }}</code></pre><p>好了。这时候，我们组装初始化电脑的时候，可以预见到以下的这种的情况</p><pre><code>class Computere{  protected $equipment;  public function __construct()  {      $this-&gt;equipment = array(          new Keyboard(&#39;my&#39;, &#39;罗技&#39;),          new Screen(&#39;1040&#39;,&#39;100&#39;),          new Mouse(true,&#39;usb&#39;),          new Fan(500,900),      );  }}</code></pre><p>后来电脑的功能越来越丰富，这时候我们创建一个新的电脑实例时候，需要实例一系列需要的类，这样处理并不优雅。可以预想像到，假如需求变更(又要临时加一个麦克风)，就需要更多具体的设备类。但是，这样如此堆砌出来的电脑，生产的效率实在是太慢了！</p></li></ul><p>聪明的人，肯定要想了，有没有一种方法能一劳永逸解决这种问题。电脑的设备可以随时被替换，只需要新增或更新一个芯片或者其他装置啥的。这样，就不用重新再来来过了。</p><p>在初始化电脑时，固化它的设备初始化的行为，而转为外部负责，由外部创造设备模块、装置或者芯片，然后植入到电脑的某一接口，这个接口是既定的。那么只要”模组”满足接口的实现，则可以提升或者增加新的一种设备。这种由外部负责其依赖的行为，我们称之为”控制反转”(Ioc)。</p><h3 id="依赖转移，工厂模式"><a href="#依赖转移，工厂模式" class="headerlink" title="依赖转移，工厂模式"></a>依赖转移，工厂模式</h3><p>当然，实现控制反转也有几种的方法，工厂模式就满足他的条件。</p><blockquote><p>我们可以联想到设备，即模组的功能是一种可被生产的玩意，生产的地方我们称之为”工厂”。于是，有人提出这么一种模式：工厂模式。</p></blockquote><pre><code>class EquitmentFactory{    public function make($moduleName, $options){        switch ($moduleName) {            case &#39;Keyboard&#39;:                 return new Keyboard($options[0], $options[1]);            case &#39;Screen&#39;:                 return new Screen($options[0], $options[1]);            ......        }    }}</code></pre><p>在创建电脑的时候初始化这个工厂：</p><pre><code>class Computer{    protected $equitment;    public function __construct(array $modules){        $factory = new EquitmentFactory();        // 通过工厂提供的方法制造需要的模组        foreach ($modules as $moduleName =&gt; $moduleOptions) {            $this-&gt;equitment[] = $factory-&gt;make($moduleName, $moduleOptions);        }    }}// 创建电脑$superman = new Superman([    &#39;Keyboard&#39; =&gt; [&#39;my&#39;, &#39;罗技&#39;],    &#39;Screen&#39; =&gt; [1040,100]]);</code></pre><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><blockquote><p>其实大多数情况下，工厂模式已经足够了。工厂模式的缺点就是：接口未知（即没有一个很好的契约模型，关于这个我马上会有解释）、产生对象类型单一。总之就是，还是不够灵活。虽然如此，工厂模式依旧十分优秀，并且适用于绝大多数情况。</p></blockquote><p>这里，我们知道电脑设备的工厂接口要求统一，这样才能和电脑本身对接，从而提升电脑的能力。</p><p>事实上，工厂模式下已经能够解决大部分的问题了。但是需求都是未知的，往往会有更加棘手的功能需要加入，这里我们就必须得改进工厂类(增加新的工厂线)：</p><pre><code>class EquitmentFactory{    public function make($moduleName, $options){        switch ($moduleName) {            case &#39;Keyboard&#39;:                 return new Keyboard($options[0], $options[1]);            case &#39;Screen&#39;:                 return new Screen($options[0], $options[1]);            //case &#39;more&#39;            //case &#39;and more&#39;            //case &#39;and more&#39;            //case &#39;oh no! its too many!&#39;        }    }}</code></pre><p>看到这里没有，噩梦的开始。。。</p><blockquote><p>其实灵感就差一步！你可能会想到更为灵活的办法！对，下一步就是我们今天的主要配角 —— DI （依赖注入）</p></blockquote><p>由于电脑需求的不断丰富，对电脑功能的要求也与日俱增。毕竟，电脑是全世界的产物，那就需要更多功能强大的设备加入，而不是仅仅被一个工厂多垄断。但是，每个人的想法又不太一样，创造的接口模组没有统一。这时候，我我们需求提供一个契约，就是无论谁创造出的设备，都符合这样的接口条件。</p><pre><code>interface EquitmentInterface{    /**       * 任何一个设备都得有该方法，并拥有一个参数     *@param array $target 针对目标，可以是一个或多个，自己或他人    */    public function activate(array $target)}</code></pre><p>这里，我们定下一个接口(即模组的规范、契约)，所有创造的设备都必须满足其条件，才能使用。</p><pre><code>class SuperKeyboard implements EquitmentInterface{    public function activate(array $target)    {        // pending    }}/** * 终极显示屏 */class SuperScreen implements EquitmentInterface{    public function activate(array $target)    {        // pending    }}</code></pre><p>然后在电脑初始化的时候，我们也有必要进行改进(为防止接口类的规范被恶意破坏，我们这里定义了只接受EquitmentInterface类型的参数)：</p><pre><code>class Computer{    protected $module;    public function __construct(EquitmentInterface $module)    {        $this-&gt;module = $module;    }}</code></pre><h4 id="什么叫做依赖注入？"><a href="#什么叫做依赖注入？" class="headerlink" title="什么叫做依赖注入？"></a><em>什么叫做依赖注入？</em></h4><p>本文从开头到现在提到的一系列依赖，只要不是由内部生产（比如初始化、构造函数 __construct 中通过工厂方法、自行手动 new 的），而是由外部以参数或其他形式注入的，都属于依赖注入（DI）</p><h3 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h3><p>先看一段代码：</p><pre><code>$SuperKeyboard = new SuperKeyboard();$SuperComputer = new Computer($SuperKeyboard);</code></pre><p>手动创建了一个super键盘类，并注入到刚刚创建的电脑类。<br>事实上，如此设计还是不够强大。我们需要一种高级的生产车间，只需要向车间提交一个指定，工厂便能自动化生产，就是工厂模式的生化-Ioc容器。</p><pre><code>class Container{    protected $binds;    protected $instances;    public function bind($class,$concrete){        if($class instanceof Closure){            //闭包函数            $this-&gt;binds[$class] = $concrete;        }else{            $this-&gt;instances[$class] = $concrete;        }    }    public function make($class,$params = []){        if(isset($this-&gt;instances[$class])){            return $this-&gt;instances[$class];        }        array_unshift($params,$this);        return call_user_func_array($this-&gt;binds[$class],$params);    }}</code></pre><p>一个粗糙简陋的容器就诞生了，下面我们来使用他：<br>//容器对象实例化<br>$container = new Container();</p><p>//向容器工厂添加电脑类的脚本<br>$container-&gt;bind(‘computer’,function($container,$moduleNmae){<br>    return new Computer($container-&gt;make($moduleName));<br>});<br>//向容器工厂添加keyboard的生产脚本<br>$container-&gt;bind(‘superKeyboard’,function($container){<br>    return new SuperKeyboard;<br>});<br>$container-&gt;bind(‘superScreen’,function($container){<br>    return new SuperScreen;<br>});</p><p>//开始生产使用<br>$computer1 = $container-&gt;make(‘computer’,’superKeyboard’);<br>$computer2 = $container-&gt;make(‘computer’,’superScreen’);<br>//…pending</p><p>看到没有？我们创建的container容器，通过它注册绑定生产脚本。生产脚本只有在执行时候才会执行。这里，我们已经成功的解决了电脑与接口设备的依赖关系，并且！容器工厂也丝毫未与他们产生任何的依赖。通过注册、绑定的方式向容器添加一段可以被执行的回调(匿名类、非匿名，还可以是普通类)作为生产的脚本，只有在make操作被执行的时候，才会触发。</p><p>实际上，真正的Ioc容器会更为高级。我们自己的例子中，还是手动注入生产脚本，但是真正的容器会根据类的依赖需求，自动在注册、绑定的实例中搜寻符合需求的依赖，并自动注入到构造函数中。这种自动搜寻依赖注入的方式，是通过反射实现的。关于反射，下一章节会有说明。<a href="http://php.net/manual/zh/book.reflection.php" target="_blank" rel="noopener">PHP官方的文档</a>也有比较详细的资料可以借鉴。</p><p>这里也感谢学院君的博客-<a href="https://xueyuanjun.com/post/769.html" target="_blank" rel="noopener">深入理解控制反转（IoC）和依赖注入</a>，前些年有去了解，但是多少有些生疏。这篇文档重拾了对依赖及控制反转的理解，在此基础上按照其思路走了一遍大有豁然开朗的领悟。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死磕设计模式-观察者模式</title>
      <link href="/2020/01/10/si-ke-she-ji-mo-shi-guan-cha-zhe-mo-shi/"/>
      <url>/2020/01/10/si-ke-she-ji-mo-shi-guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式(Observer),当一个对象的状态发生改变时，依赖他的对象会全部收到通知，并自动更新。</p><h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><p>一个事件发生后,要执行一连串更新操作.传统的编程方式,就是在事件的代码之后直接加入处理逻辑,当更新得逻辑增多之后,代码会变得难以维护.这种方式是耦合的,侵入式的,增加新的逻辑需要改变事件主题的代码</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>某个事件发生后，触发观察者方法</p><pre><code>interface ObServer{    public function update($event_info = null);}//观察者实现类1class ObServer1 implements Observer{    public function update($event_info = null){        echo &#39;我是观察者1号&#39;;    }}//观察者实现类2class ObServer2 implements Observer{    public function update($event_info = null){        echo &#39;我是观察者2号&#39;;    }}//事件class Event{    protected $ObServers;    //增加观察者    public function add(Observer $ObServer){        $this-&gt;ObServers[] = $ObServer;    }    //事件通知    public function notify(){        foreach ($this-&gt;ObServers as $ObServer) {            $ObServer-&gt;update();        }    }    //触发事件    public function trigger(){        //通知观察者        $this-&gt;notify();    }}$event = new Event();$event-&gt;add(new Observer1());$event-&gt;add(new Observer2());$event-&gt;trigger();//info 我是观察者1号我是观察者2号</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际应用开发过程中，观察者模式适用场景还是经常有碰到的。比如：平台用户注册、登录后，后台逻辑相对应更新登录信息、或者注册后更新上级推广数据等等，往往在运营的维护过程中为应对各种不同的需求，传统代码逻辑会越来越多 耦合越来越高，维护成本相应增加。观察者模式，很好的解决了这一点。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http状态码大全</title>
      <link href="/2020/01/03/http-zhuang-tai-ma-da-quan/"/>
      <url>/2020/01/03/http-zhuang-tai-ma-da-quan/</url>
      
        <content type="html"><![CDATA[<p>&lt;?php<br>// This can be found in the Symfony\Component\HttpFoundation\Response class<br>const HTTP_CONTINUE = 100;<br>const HTTP_SWITCHING_PROTOCOLS = 101;<br>const HTTP_PROCESSING = 102;            // RFC2518<br>const HTTP_OK = 200;<br>const HTTP_CREATED = 201;<br>const HTTP_ACCEPTED = 202;<br>const HTTP_NON_AUTHORITATIVE_INFORMATION = 203;<br>const HTTP_NO_CONTENT = 204;<br>const HTTP_RESET_CONTENT = 205;<br>const HTTP_PARTIAL_CONTENT = 206;<br>const HTTP_MULTI_STATUS = 207;          // RFC4918<br>const HTTP_ALREADY_REPORTED = 208;      // RFC5842<br>const HTTP_IM_USED = 226;               // RFC3229<br>const HTTP_MULTIPLE_CHOICES = 300;<br>const HTTP_MOVED_PERMANENTLY = 301;<br>const HTTP_FOUND = 302;<br>const HTTP_SEE_OTHER = 303;<br>const HTTP_NOT_MODIFIED = 304;<br>const HTTP_USE_PROXY = 305;<br>const HTTP_RESERVED = 306;<br>const HTTP_TEMPORARY_REDIRECT = 307;<br>const HTTP_PERMANENTLY_REDIRECT = 308;  // RFC7238<br>const HTTP_BAD_REQUEST = 400;<br>const HTTP_UNAUTHORIZED = 401;<br>const HTTP_PAYMENT_REQUIRED = 402;<br>const HTTP_FORBIDDEN = 403;<br>const HTTP_NOT_FOUND = 404;<br>const HTTP_METHOD_NOT_ALLOWED = 405;<br>const HTTP_NOT_ACCEPTABLE = 406;<br>const HTTP_PROXY_AUTHENTICATION_REQUIRED = 407;<br>const HTTP_REQUEST_TIMEOUT = 408;<br>const HTTP_CONFLICT = 409;<br>const HTTP_GONE = 410;<br>const HTTP_LENGTH_REQUIRED = 411;<br>const HTTP_PRECONDITION_FAILED = 412;<br>const HTTP_REQUEST_ENTITY_TOO_LARGE = 413;<br>const HTTP_REQUEST_URI_TOO_LONG = 414;<br>const HTTP_UNSUPPORTED_MEDIA_TYPE = 415;<br>const HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;<br>const HTTP_EXPECTATION_FAILED = 417;<br>const HTTP_I_AM_A_TEAPOT = 418;                                               // RFC2324<br>const HTTP_MISDIRECTED_REQUEST = 421;                                         // RFC7540<br>const HTTP_UNPROCESSABLE_ENTITY = 422;                                        // RFC4918<br>const HTTP_LOCKED = 423;                                                      // RFC4918<br>const HTTP_FAILED_DEPENDENCY = 424;                                           // RFC4918<br>const HTTP_RESERVED_FOR_WEBDAV_ADVANCED_COLLECTIONS_EXPIRED_PROPOSAL = 425;   // RFC2817<br>const HTTP_UPGRADE_REQUIRED = 426;                                            // RFC2817<br>const HTTP_PRECONDITION_REQUIRED = 428;                                       // RFC6585<br>const HTTP_TOO_MANY_REQUESTS = 429;                                           // RFC6585<br>const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;                             // RFC6585<br>const HTTP_UNAVAILABLE_FOR_LEGAL_REASONS = 451;<br>const HTTP_INTERNAL_SERVER_ERROR = 500;<br>const HTTP_NOT_IMPLEMENTED = 501;<br>const HTTP_BAD_GATEWAY = 502;<br>const HTTP_SERVICE_UNAVAILABLE = 503;<br>const HTTP_GATEWAY_TIMEOUT = 504;<br>const HTTP_VERSION_NOT_SUPPORTED = 505;<br>const HTTP_VARIANT_ALSO_NEGOTIATES_EXPERIMENTAL = 506;                        // RFC2295<br>const HTTP_INSUFFICIENT_STORAGE = 507;                                        // RFC4918<br>const HTTP_LOOP_DETECTED = 508;                                               // RFC5842<br>const HTTP_NOT_EXTENDED = 510;                                                // RFC2774<br>const HTTP_NETWORK_AUTHENTICATION_REQUIRED = 511;                             // RFC6585<br>public static $statusTexts = array(<br>    100 =&gt; ‘Continue’,<br>    101 =&gt; ‘Switching Protocols’,<br>    102 =&gt; ‘Processing’,            // RFC2518<br>    200 =&gt; ‘OK’,<br>    201 =&gt; ‘Created’,<br>    202 =&gt; ‘Accepted’,<br>    203 =&gt; ‘Non-Authoritative Information’,<br>    204 =&gt; ‘No Content’,<br>    205 =&gt; ‘Reset Content’,<br>    206 =&gt; ‘Partial Content’,<br>    207 =&gt; ‘Multi-Status’,          // RFC4918<br>    208 =&gt; ‘Already Reported’,      // RFC5842<br>    226 =&gt; ‘IM Used’,               // RFC3229<br>    300 =&gt; ‘Multiple Choices’,<br>    301 =&gt; ‘Moved Permanently’,<br>    302 =&gt; ‘Found’,<br>    303 =&gt; ‘See Other’,<br>    304 =&gt; ‘Not Modified’,<br>    305 =&gt; ‘Use Proxy’,<br>    307 =&gt; ‘Temporary Redirect’,<br>    308 =&gt; ‘Permanent Redirect’,    // RFC7238<br>    400 =&gt; ‘Bad Request’,<br>    401 =&gt; ‘Unauthorized’,<br>    402 =&gt; ‘Payment Required’,<br>    403 =&gt; ‘Forbidden’,<br>    404 =&gt; ‘Not Found’,<br>    405 =&gt; ‘Method Not Allowed’,<br>    406 =&gt; ‘Not Acceptable’,<br>    407 =&gt; ‘Proxy Authentication Required’,<br>    408 =&gt; ‘Request Timeout’,<br>    409 =&gt; ‘Conflict’,<br>    410 =&gt; ‘Gone’,<br>    411 =&gt; ‘Length Required’,<br>    412 =&gt; ‘Precondition Failed’,<br>    413 =&gt; ‘Payload Too Large’,<br>    414 =&gt; ‘URI Too Long’,<br>    415 =&gt; ‘Unsupported Media Type’,<br>    416 =&gt; ‘Range Not Satisfiable’,<br>    417 =&gt; ‘Expectation Failed’,<br>    418 =&gt; ‘I&#39;m a teapot’,                                               // RFC2324<br>    421 =&gt; ‘Misdirected Request’,                                         // RFC7540<br>    422 =&gt; ‘Unprocessable Entity’,                                        // RFC4918<br>    423 =&gt; ‘Locked’,                                                      // RFC4918<br>    424 =&gt; ‘Failed Dependency’,                                           // RFC4918<br>    425 =&gt; ‘Reserved for WebDAV advanced collections expired proposal’,   // RFC2817<br>    426 =&gt; ‘Upgrade Required’,                                            // RFC2817<br>    428 =&gt; ‘Precondition Required’,                                       // RFC6585<br>    429 =&gt; ‘Too Many Requests’,                                           // RFC6585<br>    431 =&gt; ‘Request Header Fields Too Large’,                             // RFC6585<br>    451 =&gt; ‘Unavailable For Legal Reasons’,                               // RFC7725<br>    500 =&gt; ‘Internal Server Error’,<br>    501 =&gt; ‘Not Implemented’,<br>    502 =&gt; ‘Bad Gateway’,<br>    503 =&gt; ‘Service Unavailable’,<br>    504 =&gt; ‘Gateway Timeout’,<br>    505 =&gt; ‘HTTP Version Not Supported’,<br>    506 =&gt; ‘Variant Also Negotiates’,                                     // RFC2295<br>    507 =&gt; ‘Insufficient Storage’,                                        // RFC4918<br>    508 =&gt; ‘Loop Detected’,                                               // RFC5842<br>    510 =&gt; ‘Not Extended’,                                                // RFC2774<br>    511 =&gt; ‘Network Authentication Required’,                             // RFC6585<br>);</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel实现Form表单场景验证</title>
      <link href="/2019/12/27/laravel-shi-xian-form-biao-dan-chang-jing-yan-zheng/"/>
      <url>/2019/12/27/laravel-shi-xian-form-biao-dan-chang-jing-yan-zheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Laravel没有Tp5那样的form表单验证场景，根据自己理解封装了一个类方法来实现他</p><h2 id="认知了解"><a href="#认知了解" class="headerlink" title="认知了解"></a>认知了解</h2><p>第一步：查找框架中有没有现成的工厂类可以用的，避免重复造轮子<br>demo：<br>    protected function validator(array $data)<br>    {<br>        return Validator::make($data, [<br>            ‘name’ =&gt; ‘required|max:255’,<br>            ‘email’ =&gt; ‘required|email|max:255|unique:users’,<br>            ‘password’ =&gt; ‘required|min:6|confirmed’,<br>        ]);<br>    }<br>    控制器调用：$this-&gt;validator($request-&gt;all())-&gt;validate();</p><pre><code>分析：通过 Facades 的方式创建验证器对象，validate是最终验证方法;进一步深入类方法学习研究一下，`config/app.php` 中注册了`&#39;Validator&#39; =&gt; Illuminate\Support\Facades\Validator::class`。`Validator` 的实际实现类是容器中的 `validator` 对象```php&lt;?phpnamespace Illuminate\Support\Facades;/*** @see \Illuminate\Validation\Factory*/class Validator extends Facade{    /**    * Get the registered name of the component.    *    * @return string    */    protected static function getFacadeAccessor()    {        return &#39;validator&#39;;    }}```创建验证器是通过实现 `\Illuminate\Contracts\Validation\Factory` 接口的 `\Illuminate\Validation\Factory` 类创建```protected function resolve(array $data, array $rules, array $messages, array $customAttributes){    if (is_null($this-&gt;resolver)) {        return new Validator(            $this-&gt;translator,             $data,            $rules,             $messages,             $customAttributes        );    }    return call_user_func(        $this-&gt;resolver,         $this-&gt;translator,         $data,         $rules,         $messages,         $customAttributes    );}```以上便是Validator类的实现逻辑，这里我们只需要知道如何使用即可： `Validator::make($data,$rule,$message)。`</code></pre><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><blockquote><p>defined方法getInput： 获取验证数据<br>defined方法getRules： 获取验证规则<br>defined方法getMessage： 返回验证message,<br>在check方法中，验证场景表单</p></blockquote><pre><code>$validator = Validator::make($input, $rules,$messages);//返回错误信息if ($validator-&gt;fails()) {    return $validator-&gt;errors();}return false;</code></pre><h3 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h3><pre><code>use Illuminate\Support\Facades\Validator;use Illuminate\Validation\Rules;class AbstractValidate extends Validator{    /***     * 验证字段属性     *     * @param $all     * @param $rules     * @param bool $message     * @return array|bool|string     */    protected $input;    protected $scenes = [];    protected $messages = [];    protected $rules = [];    /**     * 重写验证场景     * @param $inputs     * @param $scene     * @return bool|string     */    public function check($inputs, $scene)    {        $input = $this-&gt;getInput($inputs, $scene);        $rules = $this-&gt;getRules($scene);        $messages = $this-&gt;getMessage($rules);        $validator = Validator::make($input, $rules,$messages);        //返回错误信息        if ($validator-&gt;fails()) {            return $validator-&gt;errors(); //返回错误信息        }        return false;    }    //获取验证数据    public function getInput($inputs, $scene)    {        $input = [];        if(!isset($this-&gt;scenes[$scene]) || !is_array($this-&gt;scenes[$scene])){            return true;        }        foreach ($this-&gt;scenes[$scene] as $key =&gt; $v) {            if (array_key_exists($v, $inputs)) {                $input[$v] = $inputs[$v];            }        }        return $input;    }    /**     * 获取验证规则     * @param $scene     * @return mixed     */    public function getRules($scene)    {        $rules = [];        if (isset($this-&gt;scenes[$scene]) &amp;&amp; $this-&gt;scenes[$scene]) {            foreach ($this-&gt;scenes[$scene] as $field) {                if (array_key_exists($field, $this-&gt;rules)) {                    $rules[$field] = $this-&gt;rules[$field];                }            }        }        return $rules;    }    /***     * 返回验证message     * @return array     */    public function getMessage($rules)    {        $message = [];        foreach ($rules as $key =&gt; $v) {            $arr = explode(&#39;|&#39;, $v);            foreach ($arr as $k =&gt; $val) {                if (strpos($val, &#39;:&#39;) !== false) {                    unset($arr[$k]);                    $arr[] = substr($val, 0, strpos($val, &#39;:&#39;));                }            }            foreach ($arr as $value) {                if (array_key_exists($key . &#39;.&#39; . $value, $this-&gt;messages)) {                    $message[$key . &#39;.&#39; . $value] = $this-&gt;messages[$key . &#39;.&#39; . $value];                }            }        }        return $message;    }}</code></pre><p><em>登录表单验证示例：</em></p><pre><code>class GuestValidate extends AbstractValidate{public $rules = [        &#39;name&#39;                  =&gt; &#39;required&#39;,        &#39;phone&#39;                 =&gt; &#39;required|regex:&quot;^1\d{10}&quot;&#39;,        &#39;email&#39;                 =&gt; &#39;required|email&#39;,        &#39;password&#39;              =&gt; &#39;required&#39;,        &#39;password_confirm&#39; =&gt; &#39;required&#39;,    ];    public $messages = [        &#39;name.required&#39;  =&gt; &#39;用户名不能为空&#39;,        &#39;phone.required&#39;  =&gt; &#39;手机号不能为空&#39;,        &#39;phone.regex&#39;     =&gt; &#39;请输入正确的手机号&#39;,        &#39;email.required&#39; =&gt; &#39;请输入邮箱&#39;,        &#39;email.email&#39; =&gt; &#39;请输入正确的邮箱号&#39;,        &#39;password.email&#39; =&gt; &#39;请输入密码&#39;,    ];    public $scenes = [        &#39;login&#39;  =&gt; [&#39;email&#39;, &#39;password&#39;],        &#39;register&#39;  =&gt; [&#39;email&#39;, &#39;password&#39;,&#39;password_confirm&#39;],    ];}Controller:(new GuestValidate())-&gt;check($request-&gt;all(),&#39;login&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> 场景验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的Bash命令四-系统管理</title>
      <link href="/2019/12/22/chang-yong-de-bash-ming-ling-si-xi-tong-guan-li/"/>
      <url>/2019/12/22/chang-yong-de-bash-ming-ling-si-xi-tong-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1、top-显示-process-的动态"><a href="#1、top-显示-process-的动态" class="headerlink" title="1、top - 显示 process 的动态"></a>1、top - 显示 process 的动态</h2><p><code>top</code> 显示进程信息。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 显示进程信息</span>top<span class="token punctuation">-</span>c 显示完整命令<span class="token punctuation">-</span>b 批处理模式显示<span class="token punctuation">-</span>S 累计模式显示程序信息<span class="token punctuation">-</span>n 2 设置信息更新次数 //表示更新两次后退出<span class="token punctuation">-</span>d 3 设置信息更新时间 //表示更新周期为3秒<span class="token punctuation">-</span>p 139 显示指定的进程信息 //显示进程号为139的进程信息，CPU、内存占用率等</code></pre><h2 id="2、ps-输出进程运行情况"><a href="#2、ps-输出进程运行情况" class="headerlink" title="2、ps - 输出进程运行情况"></a>2、ps - 输出进程运行情况</h2><p><code>ps</code> 用于显示当前进程 (process) 的状态。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义</span><span class="token punctuation">-</span>A 列出所有的行程信息<span class="token punctuation">-</span>u root //显示root进程用户信息<span class="token punctuation">-</span>ef //显示所有命令，连带命令行<span class="token key atrule">PID</span><span class="token punctuation">:</span> pid<span class="token punctuation">-</span>aux 显示所有包含其他使用者的行程(这里会比<span class="token punctuation">-</span>ef 获得的资讯更详细)</code></pre><h2 id="3、lsof-netstat-查看端口占用情况"><a href="#3、lsof-netstat-查看端口占用情况" class="headerlink" title="3、lsof/netstat - 查看端口占用情况"></a>3、lsof/netstat - 查看端口占用情况</h2><p><code>lsof</code>(list open files)是一个列出当前系统打开文件的工具。<br><code>netstat</code> -tunlp 用于显示 tcp，udp 的端口和进程等相关情况。</p><pre class=" language-yaml"><code class="language-yaml">lsof<span class="token punctuation">-</span>i<span class="token punctuation">:</span>port 查看服务器 port 端口的占用情况abc.txt：显示开启文件abc.txt的进程<span class="token punctuation">-</span>c <span class="token punctuation">-</span>p 1234：列出进程号为1234的进程所打开的文件</code></pre><hr><pre class=" language-yaml"><code class="language-yaml">netstat<span class="token punctuation">-</span>tunlp <span class="token punctuation">|</span> grep 端口号<span class="token punctuation">-</span>t (tcp) 仅显示tcp相关选项<span class="token punctuation">-</span>u (udp)仅显示udp相关选项<span class="token punctuation">-</span>n 拒绝显示别名，能显示数字的全部转化为数字<span class="token punctuation">-</span>l 仅列出在Listen(监听)的服务状态<span class="token punctuation">-</span>p 显示建立相关链接的程序名</code></pre><h2 id="4、kill-杀掉对应的进程"><a href="#4、kill-杀掉对应的进程" class="headerlink" title="4、kill - 杀掉对应的进程"></a>4、kill - 杀掉对应的进程</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 查到端口占用的进程后，如果你要杀掉对应的进程可以使用 kill 命令</span>kill <span class="token punctuation">-</span>9 PID<span class="token key atrule">如</span><span class="token punctuation">:</span>kill <span class="token punctuation">-</span>9 26993 强制杀死端口号为26993的进程</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对Composer的认识</title>
      <link href="/2019/12/12/dui-composer-de-ren-shi/"/>
      <url>/2019/12/12/dui-composer-de-ren-shi/</url>
      
        <content type="html"><![CDATA[<p><img src="/medias/tmp/composer.jpg" alt="composer"><br>引自Composer中文网的描述：</p><blockquote><p>是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。<br>我们今天就来认识以下<code>Composer</code></p></blockquote><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h2 id="在说composer之前，我们先来了解一下什么组件。因为组件和composer之间密切相关，要想知道composer是如何工作的，我们要先清楚什么是组件。"><a href="#在说composer之前，我们先来了解一下什么组件。因为组件和composer之间密切相关，要想知道composer是如何工作的，我们要先清楚什么是组件。" class="headerlink" title="在说composer之前，我们先来了解一下什么组件。因为组件和composer之间密切相关，要想知道composer是如何工作的，我们要先清楚什么是组件。"></a>在说composer之前，我们先来了解一下什么组件。因为组件和composer之间密切相关，要想知道composer是如何工作的，我们要先清楚什么是组件。</h2><h3 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h3><p>组件是打包的代码，用于我们在实际项目中解决某个问题。组件适用于某个场景下使用，比如：在导入导出时候会碰到各种不同业务场景下的功能需求，直接调用excel组件的类库代码，便可自定义使用，十分方便</p><h3 id="为什么要使用组件"><a href="#为什么要使用组件" class="headerlink" title="为什么要使用组件"></a>为什么要使用组件</h3><p>避免重复造轮子</p><h3 id="组件的特点"><a href="#组件的特点" class="headerlink" title="组件的特点"></a>组件的特点</h3><ul><li>功能单一。一个方法只做一件事</li><li>专属的命名空间，遵循组件库的规范，不与其他组件冲突</li><li>开箱即用。测试方便</li><li>文档完善。</li></ul><h2 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h2><h2 id="通过composer，我们可以使用大量的第三方库，而无需自己造轮子-更加快速提高开发效率。如果说Packagist是组件库，那么composer就是PHP组件管理工具了。composer是PHP组件的依赖管理器，它在命令行中使用，简单而又方便。所以，推荐phper必须学会composer。"><a href="#通过composer，我们可以使用大量的第三方库，而无需自己造轮子-更加快速提高开发效率。如果说Packagist是组件库，那么composer就是PHP组件管理工具了。composer是PHP组件的依赖管理器，它在命令行中使用，简单而又方便。所以，推荐phper必须学会composer。" class="headerlink" title="通过composer，我们可以使用大量的第三方库，而无需自己造轮子,更加快速提高开发效率。如果说Packagist是组件库，那么composer就是PHP组件管理工具了。composer是PHP组件的依赖管理器，它在命令行中使用，简单而又方便。所以，推荐phper必须学会composer。"></a>通过<code>composer</code>，我们可以使用大量的第三方库，而无需自己造轮子,更加快速提高开发效率。如果说Packagist是组件库，那么composer就是PHP组件管理工具了。composer是PHP组件的依赖管理器，它在命令行中使用，简单而又方便。所以，推荐phper必须学会composer。</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先确认已经安装了php，并且把php设置在了全局变量中，打开命令行输入php -v能够看到php版本信息</p><pre class=" language-php"><code class="language-php">php <span class="token operator">-</span>r "<span class="token function">copy</span><span class="token punctuation">(</span>'https<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//install.phpcomposer.com/installer', 'composer-setup.php');"</span>php composer<span class="token operator">-</span>setup<span class="token punctuation">.</span>phpphp <span class="token operator">-</span>r <span class="token string">"unlink('composer-setup.php');"</span></code></pre><p>如何全局安装请看:<br><img src="/medias/tmp/composer-1.png" alt=""></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以下以<code>monolog</code>为例</p><blockquote><p>声明依赖<br>在项目目录下创建一个composer.json文件，指明依赖，比如，你的项目依赖 <code>monolog</code>：</p></blockquote><pre><code>{    &quot;require&quot;: {        &quot;monolog/monolog&quot;: &quot;1.2.*&quot;    }}</code></pre><p>如果不需要使用https，可以这么写，以解决有时候因为https造成的问题</p><pre><code>{    &quot;require&quot;: {        &quot;monolog/monolog&quot;: &quot;1.2.*&quot;    },    &quot;config&quot;: {        &quot;secure-http&quot;: false    }}</code></pre><p>安装依赖<br>安装依赖非常简单，只需在项目目录下运行：<br><code>composer install</code><br>如果没有全局安装的话，则运行：<br><code>php composer.phar install</code><br>更新全部的包（谨慎使用）：<br><code>composer update</code></p><p><em>注意：使用<code>composer install</code>或者<code>composer update</code>命令将会更新所有的扩展包，项目中使用需谨慎！！！</em></p><h3 id="切换国内镜像"><a href="#切换国内镜像" class="headerlink" title="切换国内镜像"></a>切换国内镜像</h3><p>仅当前工程可使用该镜像地址：<br><code>composer config repo.packagist composer https://mirrors.aliyun.com/composer/</code><br>取消配置：<br><code>composer config --unset repos.packagist</code></p><h3 id="命令汇总"><a href="#命令汇总" class="headerlink" title="命令汇总"></a>命令汇总</h3><pre><code>composer list  列出所有可用的命令composer init   初始化composer.json文件(就不劳我们自己费力创建啦)，会要求输入一些信息来描述我们当前的项目，还会要求输入依赖包composer install  读取composer.json内容，解析依赖关系，安装依赖包到vendor目录下composer update   更新最新的依赖关系到compsoer.lock文件，解析最新的依赖关系并且写入composer.lock文件composer search packagename 搜索包，packagename替换为你想查找的包名称composer require packagename 添加对packagename的依赖，packagename可修改为你想要的包名称composer show packagenamecomposer self-update 更新 composer.phar文件自身composer dump-autoload --optimize 优化一下自动加载composer command --help 以上所有命令都可以添加 --help选项查看帮助信息</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、利用 Composer 一步一步构建自己的 PHP 框架（一）——基础准备 - 岁寒<br><a href="https://lvwenhan.com/php/405.html" target="_blank" rel="noopener">https://lvwenhan.com/php/405.html</a></p><p>2、PHP 开发者该知道的 5 个 Composer 小技巧 - 新闻 - SegmentFault<br><a href="https://segmentfault.com/a/1190000000355928" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000355928</a></p><p>3、Composer 中文网<br><a href="http://www.phpcomposer.com/" target="_blank" rel="noopener">http://www.phpcomposer.com/</a></p><p>4、Packagist / Composer 中国全量镜像<br><a href="http://pkg.phpcomposer.com/" target="_blank" rel="noopener">http://pkg.phpcomposer.com/</a></p><p>5、Composer安装<br><a href="https://getcomposer.org/download/" target="_blank" rel="noopener">https://getcomposer.org/download/</a></p><p>6、composer之创建自己的包 - 始终不够<br><a href="http://www.huyanping.cn/composer%e4%b9%8b%e5%88%9b%e5%bb%ba%e8%87%aa%e5%b7%b1%e7%9a%84%e5%8c%85/" target="_blank" rel="noopener">http://www.huyanping.cn/composer%e4%b9%8b%e5%88%9b%e5%bb%ba%e8%87%aa%e5%b7%b1%e7%9a%84%e5%8c%85/</a></p><p>7、php - 请各位分享或推荐一下composer里面好用的包 - SegmentFault<br><a href="https://segmentfault.com/q/1010000000484379" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000484379</a></p><p>8、给 CI 插上翅膀——在 CodeIgniter 2 中使用 Laravel Eloquent ORM - 岁寒<br><a href="https://lvwenhan.com/php/414.html" target="_blank" rel="noopener">https://lvwenhan.com/php/414.html</a></p><p>9、Composer进阶使用 —— 常用命令和版本约束 - icyfire - SegmentFault<br><a href="https://segmentfault.com/a/1190000005898222" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005898222</a></p><p>10、Composer 国内加速：可用镜像列表 | Composer 技术论坛<br><a href="https://learnku.com/composer/wikis/30594" target="_blank" rel="noopener">https://learnku.com/composer/wikis/30594</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死磕设计模式-工厂模式</title>
      <link href="/2019/12/11/si-ke-she-ji-mo-shi-gong-han-mo-shi/"/>
      <url>/2019/12/11/si-ke-she-ji-mo-shi-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>根据抽象程度不同，PHP工厂模式分为：<em>简单工厂模式、工厂方法模式和抽象工厂模式</em></p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。工厂模式中，创建的对象不能太多，人们并不关心对象的创建。</p><h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><p>　　（1）需要创建的对象较少。<br>　　（2）客户端不关心对象的创建过程。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图</p><pre><code>//接口这里方法函数修饰符为publicinterface Shape{    public function draw();}//圆形class CircleShape implements Shape{    public function draw()    {        echo &#39;我是圆形draw方法&#39;;    }}//正方形class SquareShape implements Shape{    public function draw()    {        echo &#39;我是正方形draw方法&#39;;    }}//工厂模式的具体实现class FactoryShape{    public $tag = &quot;FactoryShape&quot;;    static public function getShape($shape)    {        switch ($shape) {            case &#39;circle&#39;:                return new CircleShape();                break;            case &#39;square&#39;:                return new SquareShape();                break;        }    }}FactoryShape::getShape(&#39;circle&#39;)-&gt;draw();</code></pre><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>一个用于创建对象的接口，让子类决定哪个类实例化。</p><p>略。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式是工厂方法的进一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。这是和工厂方法最大的不同点。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>　　提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。(在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的对象)</p><h3 id="示例-同上-："><a href="#示例-同上-：" class="headerlink" title="示例(同上)："></a>示例(同上)：</h3><pre><code>//定义接口interface Shape{    public function draw();}//圆形class CircleShape implements Shape{    public function draw()    {        echo &#39;我是圆形draw方法&#39;;    }}//正方形class SquareShape implements Shape{    public function draw()    {        echo &#39;我是正方形draw方法&#39;;    }}//定义抽象工厂interface CreateShape{    public function getShape();}//用于创建圆形对象的工厂类class FactoryCircle implements CreateShape{    public function getShape()    {        return new CircleShape();    }}//用于创建方形对象的工厂类class FactorySquare implements CreateShape{    public function getShape()    {        return new SquareShape();    }}//客户端clinet调用$factory_circle = new FactoryCircle();$obj = $factory_circle-&gt;getShape();$obj-&gt;draw();$factory_Square = new FactorySquare();$obj = $factory_Square-&gt;getShape();$obj-&gt;draw();</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>有多个不同的实例对象，被创建的实例具有共同的父类或接口。实现过程中不关心对象的创建过程。差异之处在：</p></li><li><blockquote><p>简单工厂模式是通过一个静态方法来创建对象<br>工厂方法模式解决简单工厂模式中的封闭开放原则<br>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口。和工厂方法模式区别在于：一系列（多个），而工厂方法只有一个。</p></blockquote></li></ul><ol><li>工厂模式分为三种：简单工厂、工厂方法、抽象工厂 。</li><li>抽象工厂由多条产品线，而工厂方法只有一条产品线，是抽象工厂的简化。而工厂方法和简单工厂相比，代码实现及功能一样 但是本质上简单工厂并未遵循开闭原则(<em>面向对象编程领域中，开闭原则规定”软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”</em>)，而工厂方法则严格的多，模式中只负责抽象工程接口，具体工厂交给客户去扩展。</li><li>分工时，核心工程师负责抽象工厂和抽象产品的定义，业务工程师负责具体工厂和具体产品的实现。只要抽象层设计的好，框架就是非常稳定的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死磕设计模式-单例模式</title>
      <link href="/2019/12/11/si-ke-she-ji-mo-shi-dan-li-mo-shi/"/>
      <url>/2019/12/11/si-ke-she-ji-mo-shi-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="单例模式有以下4个特点"><a href="#单例模式有以下4个特点" class="headerlink" title="单例模式有以下4个特点:"></a>单例模式有以下4个特点:</h3><ol><li>私有的构造方法(防止类外实例化)</li><li>私有的克隆方法(防止克隆生成对象)</li><li>私有的静态属性(保存实例)</li><li>公有的静态方法(相当于对外的api方法)</li></ol><h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ol><li>唯一序列号。</li><li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li></ol><p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>class Single{    //私有的静态属性    private $name;    static private $instance;    //声明私有的构造方法，防止其他地方实例化    private function __construct(){    }    //声明私有的克隆方法    private function __clone(){        //echo &quot;单例模式失败&quot;;    }    //公有的静态方法     static public function getInstance(){         if(!self::$instance){             self::$instance = new self();         }         return self::$instance;     }     public function setName($name){         $this-&gt;name = $name;      }     public function getName(){         return $this-&gt;name;     }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2019/12/11/markdown/"/>
      <url>/2019/12/11/markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="Markdown是一种纯文本格式的标记语言。简单的标记语法，是它作为众多文档编写语言选择的优点之一"><a href="#Markdown是一种纯文本格式的标记语言。简单的标记语法，是它作为众多文档编写语言选择的优点之一" class="headerlink" title="Markdown是一种纯文本格式的标记语言。简单的标记语法，是它作为众多文档编写语言选择的优点之一"></a>Markdown是一种纯文本格式的标记语言。简单的标记语法，是它作为众多文档编写语言选择的优点之一</h2><h3 id="table标签"><a href="#table标签" class="headerlink" title="table标签:"></a>table标签:</h3><pre class=" language-html"><code class="language-html"> |ID|名称|title|创建时间| |-|-|-|-| |2|1113|2223|2019-10-28 16:54:37| |1|活动一|我是title|2019-09-26 17:00:32|</code></pre><table><thead><tr><th>ID</th><th>名称</th><th>title</th><th>创建时间</th></tr></thead><tbody><tr><td>2</td><td>1113</td><td>2223</td><td>2019-10-28 16:54:37</td></tr><tr><td>1</td><td>活动一</td><td>我是title</td><td>2019-09-26 17:00:32</td></tr></tbody></table><h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签:"></a>a标签:</h3><pre class=" language-html"><code class="language-html">[普通链接](https://www.mdeditor.com/ "")</code></pre><p><a href="https://www.mdeditor.com/" target="_blank" rel="noopener">普通链接</a></p><h3 id="blockquote标签"><a href="#blockquote标签" class="headerlink" title="blockquote标签:"></a>blockquote标签:</h3><pre class=" language-html"><code class="language-html">>我是时间轴线</code></pre><blockquote><p>我是时间轴线</p></blockquote><h3 id="code标签"><a href="#code标签" class="headerlink" title="code标签:"></a>code标签:</h3><pre class=" language-html"><code class="language-html">`<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>?php`</span><span class="token attr-name">`echo</span> <span class="token attr-name">"Hello</span> <span class="token attr-name">World";`</span><span class="token attr-name">`</span><span class="token punctuation">></span></span>`</code></pre><p><code>&lt;?php</code></p><p><code>echo &quot;Hello World&quot;;</code></p><p><code>&gt;</code></p><h3 id="h标签"><a href="#h标签" class="headerlink" title="h标签:"></a>h标签:</h3><pre class=" language-html"><code class="language-html"># 我是h1## 我是h2### 我是h3#### 我是h4##### 我是h5###### 我是h6</code></pre><h1 id="我是h1"><a href="#我是h1" class="headerlink" title="我是h1"></a>我是h1</h1><h2 id="我是h2"><a href="#我是h2" class="headerlink" title="我是h2"></a>我是h2</h2><h3 id="我是h3"><a href="#我是h3" class="headerlink" title="我是h3"></a>我是h3</h3><h4 id="我是h4"><a href="#我是h4" class="headerlink" title="我是h4"></a>我是h4</h4><h5 id="我是h5"><a href="#我是h5" class="headerlink" title="我是h5"></a>我是h5</h5><h6 id="我是h6"><a href="#我是h6" class="headerlink" title="我是h6"></a>我是h6</h6><h3 id="hr标签"><a href="#hr标签" class="headerlink" title="hr标签:"></a>hr标签:</h3><pre class=" language-html"><code class="language-html">---</code></pre><hr><h3 id="i标签"><a href="#i标签" class="headerlink" title="i标签:"></a>i标签:</h3><pre class=" language-html"><code class="language-html">*我是斜体*</code></pre><p><em>我是斜体</em></p><h3 id="ul标签"><a href="#ul标签" class="headerlink" title="ul标签:"></a>ul标签:</h3><pre class=" language-html"><code class="language-html">* 列表一* 列表二* 列表三</code></pre><ul><li>列表一</li><li>列表二</li><li>列表三</li></ul><h3 id="ol标签"><a href="#ol标签" class="headerlink" title="ol标签:"></a>ol标签:</h3><pre class=" language-html"><code class="language-html">1.  第一行2.  第二行3.  第三行</code></pre><ol><li>第一行</li><li>第二行</li><li>第三行</li></ol><h3 id="strike标签"><a href="#strike标签" class="headerlink" title="strike标签:"></a>strike标签:</h3><pre class=" language-html"><code class="language-html">~~我是删除线~~</code></pre><p><del>我是删除线</del></p><h3 id="strong标签"><a href="#strong标签" class="headerlink" title="strong标签:"></a>strong标签:</h3><pre class=" language-html"><code class="language-html">**我是粗体**</code></pre><p><strong>我是粗体</strong></p><p>基于对markdown的热爱，github上创建了新的project，关于html格式转化为markdown的转化。以后，看到一些好的文章就方便借鉴(抄)过来了 哈哈哈(低调)<br>传送门：<a href="https://github.com/DamonNie/markdown" target="_blank" rel="noopener">欢迎fork</a></p><p>参考地址：<a href="https://markdown-zh.readthedocs.io/en/latest/" target="_blank" rel="noopener" title="Markdown中文教程"> Markdown 中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用软件工具合集</title>
      <link href="/2019/12/11/chang-yong-ruan-jian-gong-ju-he-ji/"/>
      <url>/2019/12/11/chang-yong-ruan-jian-gong-ju-he-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="开发神器-Vscode工具"><a href="#开发神器-Vscode工具" class="headerlink" title="开发神器-Vscode工具"></a>开发神器-Vscode工具</h2><p><a href="/files/tools/VSCodeSetup-x64-1.41.0.exe">Vscode</a></p><h2 id="php集成开发环境-wamp"><a href="#php集成开发环境-wamp" class="headerlink" title="php集成开发环境-wamp"></a>php集成开发环境-wamp</h2><p><a href="/files/tools/wampserver3.1.7_x64.exe">wamp</a><br><a href="/files/tools/MSVBCRT.AIO_2019.03.02.X64.exe">补丁</a> 如若安装wamp后启动，提示缺失dll文件 则执行并安装</p><h2 id="mysql工具-Navicat-Premium"><a href="#mysql工具-Navicat-Premium" class="headerlink" title="mysql工具-Navicat Premium"></a>mysql工具-Navicat Premium</h2><p>[Navicat Premium](/files/tools/Navicat Premium.zip)</p><h2 id="bash工具-git"><a href="#bash工具-git" class="headerlink" title="bash工具-git"></a>bash工具-git</h2><p><a href="/files/tools/Git-2.21.0-64-bit.exe">Git</a></p><h2 id="组件工具-Composer"><a href="#组件工具-Composer" class="headerlink" title="组件工具-Composer"></a>组件工具-Composer</h2><p><a href="/files/tools/Composer-Setup.exe">Composer</a></p><h2 id="远程服务器终端工具-Xshell"><a href="#远程服务器终端工具-Xshell" class="headerlink" title="远程服务器终端工具-Xshell"></a>远程服务器终端工具-Xshell</h2><p><a href="/files/tools/Xshell.6.0.0117.7z">Xshell</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的Bash命令(三) 文本处理</title>
      <link href="/2019/12/10/bash3/"/>
      <url>/2019/12/10/bash3/</url>
      
        <content type="html"><![CDATA[<h2 id="1、sort-排序文件"><a href="#1、sort-排序文件" class="headerlink" title="1、sort - 排序文件"></a>1、sort - 排序文件</h2><p><code>sort</code> 命令用于将文本文件的行排序。默认情况下，sort命令是按照字符串的字母顺序排序。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 将文本内容按字母顺序排序</span>sort example.txt<span class="token punctuation">-</span><span class="token key atrule">u</span><span class="token punctuation">:</span> 移除所有重复行后排序 <span class="token punctuation">-</span><span class="token key atrule">n</span><span class="token punctuation">:</span> 按照数字按数值的大小排序<span class="token punctuation">-</span><span class="token key atrule">r</span><span class="token punctuation">:</span> 倒序方式排序</code></pre><h2 id="2、uniq-文本去重"><a href="#2、uniq-文本去重" class="headerlink" title="2、uniq - 文本去重"></a>2、uniq - 文本去重</h2><p><code>uniq</code> 命令用于移除或发现文件中重复的条目。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 它将移除文件中重复的行并显示单一行</span>uniq example.txt<span class="token punctuation">-</span><span class="token key atrule">c</span><span class="token punctuation">:</span> 统计重复行出现的次数<span class="token punctuation">-</span><span class="token key atrule">d</span><span class="token punctuation">:</span> 只显示文件中有重复的行并只显示一次<span class="token punctuation">-</span><span class="token key atrule">D</span><span class="token punctuation">:</span> 显示文件中所有重复的行<span class="token punctuation">-</span><span class="token key atrule">u</span><span class="token punctuation">:</span> 只显示文件中不重复的行</code></pre><h2 id="3、grep-查找字符串"><a href="#3、grep-查找字符串" class="headerlink" title="3、grep - 查找字符串"></a>3、grep - 查找字符串</h2><p><code>grep</code> 搜索文本或指定的文件中与指定的字符串或模式相匹配的行。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># `grep`命令查找文件/etc/passwd 中帐号 damon 的信息</span>grep damon /etc/passwd<span class="token punctuation">-</span><span class="token key atrule">i</span><span class="token punctuation">:</span> 忽略搜索关键字的大小写<span class="token punctuation">-</span><span class="token key atrule">r</span><span class="token punctuation">:</span> 递归搜索指定目录下的所有文件<span class="token punctuation">-</span><span class="token key atrule">w</span><span class="token punctuation">:</span> 只匹配包含指定单词的行<span class="token punctuation">-</span><span class="token key atrule">c</span><span class="token punctuation">:</span> 报告文件或文本中模式被匹配的次数<span class="token punctuation">-</span><span class="token key atrule">n</span><span class="token punctuation">:</span> 显示每一个匹配的行的行号<span class="token punctuation">-</span><span class="token key atrule">v</span><span class="token punctuation">:</span> 输出除匹配指定模式的行以外的其他所有行<span class="token punctuation">-</span><span class="token key atrule">-color</span><span class="token punctuation">:</span> 输出将匹配的字符串以彩色的形式标出</code></pre><h2 id="4、diff-查找字符串"><a href="#4、diff-查找字符串" class="headerlink" title="4、diff - 查找字符串"></a>4、diff - 查找字符串</h2><p><code>diff</code> 命令用于比较两个文件，并找出它们之间的不同。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 比较两个文件</span>diff nsswitch.conf nsswitch.conf.org<span class="token punctuation">-</span><span class="token key atrule">w</span><span class="token punctuation">:</span> 忽略空格<span class="token punctuation">-</span><span class="token key atrule">y</span><span class="token punctuation">:</span> 以并排的格式输出两个文件的比较结果（这个比较实用些）<span class="token punctuation">-</span><span class="token key atrule">c</span><span class="token punctuation">:</span> 上下对比的格式输出两个文件的比较结果</code></pre><h2 id="5、cat-显示文件内容"><a href="#5、cat-显示文件内容" class="headerlink" title="5、cat - 显示文件内容"></a>5、cat - 显示文件内容</h2><p><code>cat</code> 查看文件的内容、连接文件、创建一个或多个文件和重定向输出到终端或文件。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 使用 cat 命令查看文件 /etc/group 的内容</span>cat /etc/group<span class="token punctuation">-</span><span class="token key atrule">n</span><span class="token punctuation">:</span> 显示行号<span class="token punctuation">-</span><span class="token key atrule">b</span><span class="token punctuation">:</span> 只显示非空白行的行号<span class="token punctuation">-</span><span class="token key atrule">e</span><span class="token punctuation">:</span> 在每一行的结尾显示“$”字符</code></pre><h2 id="6、less、more-分屏显示文件"><a href="#6、less、more-分屏显示文件" class="headerlink" title="6、less、more - 分屏显示文件"></a>6、less、more - 分屏显示文件</h2><p><code>more</code> 用于一次翻阅一整屏文件的过滤器。<br><code>less</code> 与’more’命令类似，但是支持向前和向后翻页。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 查看一个文件，自动清空屏幕并显示文件开头部分</span>more /etc/inittab<span class="token punctuation">-</span><span class="token key atrule">num</span><span class="token punctuation">:</span> 指定一次显示num行<span class="token punctuation">></span> less常用命令参数如下：<span class="token punctuation">-</span>f  强迫打开特殊文件，例如外围设备代号、目录和二进制文件<span class="token punctuation">-</span>i  忽略搜索时的大小写<span class="token punctuation">-</span>N  显示每行的行号<span class="token punctuation">-</span>Q  不使用警告音<span class="token punctuation">-</span>s  显示连续空行为一行/字符串：向下搜索“字符串”的功能<span class="token punctuation">?</span>字符串：向上搜索“字符串”的功能n： 重复前一个搜索（与 / 或 <span class="token punctuation">?</span> 有关）u  向前滚动半页y  向前滚动一行d  向后翻半页b  向后翻一页h  显示帮助界面Q  退出less 命令空格键 滚动一行回车键 滚动一页</code></pre><h2 id="7、tail、head-显示文件头部、尾部"><a href="#7、tail、head-显示文件头部、尾部" class="headerlink" title="7、tail、head 显示文件头部、尾部"></a>7、tail、head 显示文件头部、尾部</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 指定打印文件的前/后5行</span><span class="token punctuation">-</span>n 5 &lt;file<span class="token punctuation">></span><span class="token punctuation">-</span>5 &lt;file<span class="token punctuation">></span><span class="token comment" spellcheck="true">#  打印文件的前/后N个字节的数据</span><span class="token punctuation">-</span>c N<span class="token comment" spellcheck="true"># 及时跟新打印的文件数据(适用于tail)</span><span class="token punctuation">-</span>f<span class="token punctuation">-</span>f <span class="token punctuation">-</span><span class="token punctuation">-</span>retry 稍后才会创建</code></pre><h2 id="8、wc-查看文件统计信息"><a href="#8、wc-查看文件统计信息" class="headerlink" title="8、wc - 查看文件统计信息"></a>8、wc - 查看文件统计信息</h2><p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 其中X表示行数，Y表示单词数，Z表示字节数，filename表示文件名。</span>wc filenameX Y Z /etc/inittab<span class="token punctuation">-</span>l 只统计文件的行数信息(行数)<span class="token punctuation">-</span>w 只统计文件的单词数信息(单词个数)<span class="token punctuation">-</span>c 只统计文件的字节数信息(字节byte数)<span class="token punctuation">-</span>L 只统计文件中最长的行的长度</code></pre><h2 id="9、find-查找文件或目录"><a href="#9、find-查找文件或目录" class="headerlink" title="9、find - 查找文件或目录"></a>9、find - 查找文件或目录</h2><pre class=" language-yaml"><code class="language-yaml">以下列出常用的几种场景命令：<span class="token comment" spellcheck="true"># 在当前目录下查找名称为 inittab 的文件</span>find . <span class="token punctuation">-</span>name inittab<span class="token comment" spellcheck="true"># 找出 /tmp 目录下，所有者是 root 的文件和目录</span>find /tmp/ <span class="token punctuation">-</span>user root<span class="token comment" spellcheck="true"># 找出你账号的主目录下，30 天以前修改的所有文件</span>find ~ <span class="token punctuation">-</span>type f <span class="token punctuation">-</span>mtime +30<span class="token comment" spellcheck="true"># 找出你账号的主目录下，3 天以内修改的所有文件</span>find ~ <span class="token punctuation">-</span>type f <span class="token punctuation">-</span>mtime <span class="token punctuation">-</span><span class="token number">3</span><span class="token comment" spellcheck="true"># 找出你账号主目录下，大小是50MB的所有文件</span>find ~ <span class="token punctuation">-</span>type f <span class="token punctuation">-</span>size 50MB<span class="token comment" spellcheck="true"># 找出你账号主目录下，大于50MB小于100MB的所有文件</span>find ~ <span class="token punctuation">-</span>type f <span class="token punctuation">-</span>size +50MB <span class="token punctuation">-</span>size <span class="token punctuation">-</span>100MB</code></pre><h2 id="10、awk-查找文件"><a href="#10、awk-查找文件" class="headerlink" title="10、awk - 查找文件"></a>10、awk - 查找文件</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">用法一</span><span class="token punctuation">:</span>awk '<span class="token punctuation">{</span><span class="token punctuation">[</span>pattern<span class="token punctuation">]</span> action<span class="token punctuation">}</span>' <span class="token punctuation">{</span>filenames<span class="token punctuation">}</span>   <span class="token comment" spellcheck="true"># 行匹配语句 awk '' 只能用单引号</span><span class="token comment" spellcheck="true"># 每行按空格或TAB分割，输出文本中的1、4项</span>awk '<span class="token punctuation">{</span>print $1<span class="token punctuation">,</span>$4<span class="token punctuation">}</span>' log.txt<span class="token key atrule">用法二</span><span class="token punctuation">:</span>awk <span class="token punctuation">-</span>F  <span class="token comment" spellcheck="true">#-F相当于内置变量FS, 指定分割字符</span><span class="token key atrule">用法三</span><span class="token punctuation">:</span>awk <span class="token punctuation">-</span>v  <span class="token comment" spellcheck="true"># 设置变量</span>实例：<span class="token key atrule">用法四</span><span class="token punctuation">:</span>awk <span class="token punctuation">-</span>f <span class="token punctuation">{</span>awk脚本<span class="token punctuation">}</span> <span class="token punctuation">{</span>文件名<span class="token punctuation">}</span>实例：awk <span class="token punctuation">-</span>f cal.awk log.txt</code></pre><h3 id="进阶篇："><a href="#进阶篇：" class="headerlink" title="进阶篇："></a>进阶篇：</h3><p>查询一个日志文件中访问次数最多前10个IP？</p><p>第一步：按照IP进行将记录排序。</p><p>第二步：按照IP去重，并且显示重复次数</p><p>第三步：按照次数升序排列</p><p>第四步：显示前10行</p><p>awk ‘{print $1}’ log.txt | sort | uniq -c | sort -n -r | head -n 10</p><p>参考：<a href="https://blinkfox.github.io/2018/10/11/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-wen-ben-chu-li/" target="_blank" rel="noopener">常用Bash命令整理之文本处理</a><a href="https://blinkfox.github.io/2018/10/09/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cha-kan-wen-jian-he-mu-lu/" target="_blank" rel="noopener">常用Bash命令整理之查看文件和目录</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的Bash命令(二) 文件管理</title>
      <link href="/2019/12/08/bash2/"/>
      <url>/2019/12/08/bash2/</url>
      
        <content type="html"><![CDATA[<h2 id="1、touch-创建文件"><a href="#1、touch-创建文件" class="headerlink" title="1、touch - 创建文件"></a>1、touch - 创建文件</h2><p><code>touch</code> 命令就可用于创建、变更和修改文件的时间戳。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">-a</span><span class="token punctuation">:</span> 只改变访问时间 <span class="token punctuation">-</span><span class="token key atrule">c</span><span class="token punctuation">:</span> 不创建任何文件<span class="token punctuation">-</span><span class="token key atrule">m</span><span class="token punctuation">:</span> 只改变修改时间<span class="token punctuation">-</span><span class="token key atrule">r</span><span class="token punctuation">:</span> 使用指定文件的时间替代当前时间<span class="token punctuation">-</span><span class="token key atrule">t</span><span class="token punctuation">:</span> 使用 <span class="token punctuation">[</span><span class="token punctuation">[</span>CC<span class="token punctuation">]</span>YY<span class="token punctuation">]</span>MMDDhhmm<span class="token punctuation">[</span>.ss<span class="token punctuation">]</span> 替代当前时间</code></pre><h2 id="2、mkdir-创建目录"><a href="#2、mkdir-创建目录" class="headerlink" title="2、mkdir - 创建目录"></a>2、mkdir - 创建目录</h2><p><code>mkdir</code> 创建文件目录。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 在当前目录下创建一个给定的目录名</span>mkdir &lt;dirname<span class="token punctuation">></span><span class="token comment" spellcheck="true"># 使用 -p 选项，会自动创建所有还不存在的父目录</span>mkdir <span class="token punctuation">-</span>p backup/old</code></pre><h2 id="3、cp-复制文件或目录"><a href="#3、cp-复制文件或目录" class="headerlink" title="3、cp - 复制文件或目录"></a>3、cp - 复制文件或目录</h2><p><code>cp</code> 命令用于将文件从一个地方复制到另一个地方。<br>示例如下:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 在当前目录下，创建一个文件 file.txt 的副本，取名为 newfile.txt</span>cp file.txt newfile.txt<span class="token comment" spellcheck="true"># 复制当前目录下的 file.txt 文件到 /tmp 目录下</span>cp file.txt /tmp<span class="token comment" spellcheck="true"># 使用 -R 或 -r 选项，递归地复制一个目录</span><span class="token comment" spellcheck="true"># 即将一个目录及其下的所有文件和子目录都复制到另一个目录</span>cp <span class="token punctuation">-</span>R * /home/blinkfox/backup</code></pre><h2 id="4、scp-远程复制文件或目录"><a href="#4、scp-远程复制文件或目录" class="headerlink" title="4、scp - 远程复制文件或目录"></a>4、scp - 远程复制文件或目录</h2><p><code>scp</code>远程复制某服务器的一个文件到另一个服务器。命令的语法如下所示：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">-r</span><span class="token punctuation">:</span> 递归地复制一个目录<span class="token punctuation">-</span><span class="token key atrule">P</span><span class="token punctuation">:</span> 设置命令的端口号 <span class="token comment" spellcheck="true"># 从本地复制到远程(第二个指定了文件名)</span> scp local_file remote_username@remote_ip<span class="token punctuation">:</span>remote_folder  或者  scp local_file remote_username@remote_ip<span class="token punctuation">:</span>remote_file  <span class="token comment" spellcheck="true"># 从远程复制到本地(...)</span> scp remote_username@remote_ip<span class="token punctuation">:</span>remote_folder local_folder 或者  scp remote_username@remote_ip<span class="token punctuation">:</span>remote_file remote_file<span class="token comment" spellcheck="true"># 远程服务器防火墙有为scp命令设置了指定的端口</span><span class="token comment" spellcheck="true">#scp 命令使用端口号 4588</span> scp <span class="token punctuation">-</span>P 4588 remote@www.runoob.com<span class="token punctuation">:</span>/usr/local/sin.sh /home/administrator</code></pre><h2 id="5、mv-移动文件或目录"><a href="#5、mv-移动文件或目录" class="headerlink" title="5、mv - 移动文件或目录"></a>5、mv - 移动文件或目录</h2><p> <code>mv</code>命令用于将文件和目录从一个位置移到另外一个位置。命令的语法如下所示：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 将当前目录下的文件 source.txt 移到目录 /tmp 下</span>mv source.txt /tmp<span class="token comment" spellcheck="true"># 将目录 dir1、dir2 移到目录 dir_dist 下</span>mv dir1 dir2 dir_dist<span class="token comment" spellcheck="true"># 将当前目录下的 old.txt 文件更名为 new.txt</span>mv old.txt new.txt</code></pre><h2 id="6、-ln-链接文件或目录"><a href="#6、-ln-链接文件或目录" class="headerlink" title="6、 ln - 链接文件或目录"></a>6、 ln - 链接文件或目录</h2><p><code>ln</code>命令用于创建软链接或硬链接。使用 -s 选项，可以创建一个软链接：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 在目录 lib 下创建一个软链接 lib.so，链接到 /home/damon/src/library.so</span>ln <span class="token punctuation">-</span>s /home/damon/src/lib.so /home/damon/lib<span class="token comment" spellcheck="true"># 创建目录的软链接</span>ln <span class="token punctuation">-</span>s /home/damon/src source<span class="token comment" spellcheck="true">## 7、 rm - 删除文件或目录</span>`rm`删除文件或目录。示例如下：```yaml<span class="token comment" spellcheck="true"># 删除当前目录下的文件 file1.txt、file2.txt、file3.txt</span>rm file1.txt file2.txt file3.txt<span class="token comment" spellcheck="true"># 使用 -i 选项，可以在删除每个文件或目录前提示用户确认</span>rm <span class="token punctuation">-</span>i *<span class="token comment" spellcheck="true"># 删除当前目录下所有以".doc"结尾的文件</span>rm *.doc<span class="token comment" spellcheck="true"># 删除 /tmp 目录下的所有文件及其子目录(慎用)</span>rm <span class="token punctuation">-</span>rf /tmp/*</code></pre><p>参考：[常用Bash命令整理之操作文件和目录]（<a href="https://blinkfox.github.io/2018/10/10/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cao-zuo-wen-jian-he-mu-lu/）" target="_blank" rel="noopener">https://blinkfox.github.io/2018/10/10/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-cao-zuo-wen-jian-he-mu-lu/）</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的Bash命令(一)</title>
      <link href="/2019/12/08/bash/"/>
      <url>/2019/12/08/bash/</url>
      
        <content type="html"><![CDATA[<h2 id="1、hostname-查看主机名"><a href="#1、hostname-查看主机名" class="headerlink" title="1、hostname - 查看主机名"></a>1、hostname - 查看主机名</h2><p><code>hostname</code> 命令用于查看系统的主机名，亦或修改系统的主机名<br><code>hostname</code> 的常用命令如下:</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 显示系统的当前主机名</span>hostname<span class="token comment" spellcheck="true">#修改系统的主机名</span>hostname damon<span class="token punctuation">-</span>system</code></pre><h2 id="2、uptime-查看系统运行时间"><a href="#2、uptime-查看系统运行时间" class="headerlink" title="2、uptime - 查看系统运行时间"></a>2、uptime - 查看系统运行时间</h2><pre class=" language-yaml"><code class="language-yaml">uptime</code></pre><h2 id="3、who-列出登录的用户"><a href="#3、who-列出登录的用户" class="headerlink" title="3、who - 列出登录的用户"></a>3、who - 列出登录的用户</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 显示当前登录的所有用户信息</span>who<span class="token comment" spellcheck="true"># 显示系统的启动时间</span>who <span class="token punctuation">-</span>b<span class="token comment" spellcheck="true"># 显示系统登录进程</span>who <span class="token punctuation">-</span>l<span class="token comment" spellcheck="true"># 显示当前登录用户关联的用户信息</span>who <span class="token punctuation">-</span>m<span class="token comment" spellcheck="true"># 显示所有登录用户的用户名和用户数</span>who <span class="token punctuation">-</span>q</code></pre><h2 id="4、uname-查看系统信息"><a href="#4、uname-查看系统信息" class="headerlink" title="4、uname - 查看系统信息"></a>4、uname - 查看系统信息</h2><p><code>uname</code>命令用于打印内核名称和版本、主机名等系统信息。命令的语法如下所示：</p><pre class=" language-yaml"><code class="language-yaml"> <span class="token comment" spellcheck="true"># 只打印内核的名称</span> uname <span class="token comment" spellcheck="true"># 使用 -n 选项，只打印系统的主机名</span> uname <span class="token punctuation">-</span>n <span class="token comment" spellcheck="true"># 使用 -r 选项，打印内核版本信息</span> uname <span class="token punctuation">-</span>r <span class="token comment" spellcheck="true"># 使用 -m 选项，打印系统的硬件名称</span> uname <span class="token punctuation">-</span>m <span class="token comment" spellcheck="true"># 使用 -p 选项，打印系统的处理器类型信息</span> uname <span class="token punctuation">-</span>p <span class="token comment" spellcheck="true"># 使用 -i 选项，打印系统的硬件平台信息</span> uname <span class="token punctuation">-</span>i <span class="token comment" spellcheck="true"># 使用 -a 选项，打印上述所有示例中的信息</span> uname <span class="token punctuation">-</span>a</code></pre><h2 id="5、date-显示系统时间"><a href="#5、date-显示系统时间" class="headerlink" title="5、date - 显示系统时间"></a>5、date - 显示系统时间</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 以默认格式显示系统的当前日期时间</span>date<span class="token comment" spellcheck="true"># 格式化当前日期</span>date +"%Y<span class="token punctuation">-</span>%m<span class="token punctuation">-</span>%d"</code></pre><h2 id="6、-id-显示用户属性"><a href="#6、-id-显示用户属性" class="headerlink" title="6、 id - 显示用户属性"></a>6、 id - 显示用户属性</h2><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 输出当前用户的uid、用户名、gid、组名及用户属于的群组信息</span>id<span class="token comment" spellcheck="true"># 使用 -u 选项，输出用户的 uid</span>id <span class="token punctuation">-</span>u<span class="token comment" spellcheck="true">#-u 选项和 -n 选项结合使用，输出账户的用户名</span>id <span class="token punctuation">-</span>un</code></pre><p>引用：<a href="https://blinkfox.github.io/2018/10/13/ruan-jian-gong-ju/linux/chang-yong-bash-ming-ling-zheng-li-zhi-qi-ta-chang-yong-ming-ling/" target="_blank" rel="noopener">常用Bash命令整理之其他常用命令</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Git Submodule 管理项目</title>
      <link href="/2019/12/06/git-submodule/"/>
      <url>/2019/12/06/git-submodule/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Pending</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong><strong>使用场景</strong></strong></h2><p>基于公司的项目会越来越多，常常需要提取一个公共的类库提供给多个项目使用，但是这个library怎么和git在一起方便管理呢？</p><p>我们需要解决下面几个问题：</p><ul><li><p>如何在git项目中导入library库?</p><p>  answer:git submodule add【library-url】，参考<span style="color: #ff0000;">【<strong><strong>使用submodule】</strong></strong></span>。</p><p><img src="/medias/images/submodule-1.png" alt=""></p></li><li><p>library库在其他的项目中被修改了可以更新到远程的代码库中?</p><p>  answer:可以，<span style="color: #ff0000;">需要在submodule目录更新提交</span>，在业务架构中建议<span style="color: #ff0000;">单人操作更新提交</span>，实现读写剥离</p></li><li><p>其他项目如何获取到library库最新的提交?</p><p>  answer:<span style="color: #ff0000;">【<strong><strong>使用submodule】</strong></strong></span>中有说明每个submodule中有独立的commit id，依赖commit id单独管理submodule目录，依据submodule目录中commit id是否与公共库的同步选择是否更新</p><p><img src="/medias/images/submodule-2.png" alt=""></p></li><li><p>如何在clone的时候能够自动导入library库?</p><p>  answer:参考【Clone Submodule】，此处<span style="color: #ff0000;">建议方法二</span></p></li></ul><p>解决以上问题，可以考虑使用git的 Submodule来解决。</p><h2 id="什么是Submodule"><a href="#什么是Submodule" class="headerlink" title="什么是Submodule?"></a><strong><strong>什么是Submodule?</strong></strong></h2><pre><code>&lt;span style=&quot;color: #ff0000;&quot;&gt;git Submodule&lt;/span&gt; 是一个很好的多项目使用共同类库的工具，他允许类库项目做为&lt;span style=&quot;color: #ff0000;&quot;&gt;repository&lt;/span&gt;,子项目做为一个&lt;span style=&quot;color: #ff0000;&quot;&gt;单独的git项目&lt;/span&gt;存在父项目中，子项目可以有自己的独立的&lt;span style=&quot;color: #ff0000;&quot;&gt;commit，push，pull&lt;/span&gt;。而父项目以Submodule的形式&lt;span style=&quot;color: #ff0000;&quot;&gt;包含子项目&lt;/span&gt;，父项目可以&lt;span style=&quot;color: #ff0000;&quot;&gt;指定子项目header&lt;/span&gt;，父项目中会的&lt;span style=&quot;color: #ff0000;&quot;&gt;提交信息包含Submodule的信息&lt;/span&gt;，再clone父项目的时候可以把&lt;span style=&quot;color: #ff0000;&quot;&gt;Submodule初始化&lt;/span&gt;。</code></pre><h2 id="使用Submodule"><a href="#使用Submodule" class="headerlink" title="使用Submodule"></a><strong><strong>使用Submodule</strong></strong></h2><ul><li>使用git命令直接<span style="color: #ff0000;">添加Submodule</span>：</li></ul><p>git submodule add <a href="mailto:git@github.com:ronnylt/redlock-php.git" target="_blank" rel="noopener"><u>git@github.com:damonnie/redlock-php.git</u></a> redlock（别名）</p><ul><li><p>使用<span style="color: #ff0000;">git status</span>命令查看当前仓库状态：</p><p> <img src="/medias/images/submodule-3.png" alt=""></p></li></ul><p>可以看到多了两个需要提交的文件：.<span style="color: #ff0000;">gitmodules</span>和 <span style="color: #ff0000;">redlock</span></p><ul><li><p>.gitmodules 内容<span style="color: #ff0000;">包含Submodule的主要信息</span>，指定<span style="color: #ff0000;">reposirory</span>,指定路径:</p><p><img src="/medias/images/submodule-4.png" alt=""></p></li><li><p>要查看当前代码仓库所使用的子模块及其状态，除了看 .gitmodules 文件外，还可以执行 <span style="color: #ff0000;">git submodule</span>命令</p><p> <img src="/medias/images/submodule-5.png" alt=""></p></li><li><p>新文件redlock<span style="color: #ff0000;">保存子模块的信息</span>，默认情况下子模块会将子项目放到一个与仓库<span style="color: #ff0000;">同名的目录中</span>，本例中是redlock。如果想放到其他地方，那么可以命令后添加一个<span style="color: #ff0000;">不同的路径</span>。此处，可以添加多个不同的子模块</p><p> <img src="/medias/images/submodule-6.png" alt=""></p></li></ul><p>这里需要说明的是，submodule目录只保护子项目的commit id，父项目的git并不会记录submodule的文件变动。另外，这两个文件都需要提交到父项目的git中</p><h2 id="修改Submodule-业务仓库只读，公共仓库更新"><a href="#修改Submodule-业务仓库只读，公共仓库更新" class="headerlink" title="修改Submodule(业务仓库只读，公共仓库更新)"></a><strong><strong>修改Submodule(</strong></strong><span style="color: #ff0000;"><strong><strong>业务仓库只读，公共仓库更新</strong></strong></span><strong><strong>)</strong></strong></h2><ul><li><p>需要确认有对Submodule的commit权限：</p><pre><code> &lt;span style=&quot;background-color: #999999;&quot;&gt;cd redlock &lt;/span&gt;</code></pre></li><li><p>修改其中的一个文件，git status查看变动：</p><pre><code> &lt;span style=&quot;background-color: #999999;&quot;&gt;modified:   README.md&lt;/span&gt;</code></pre></li><li><p>提交更改内容，并push远程</p><pre><code> &lt;span style=&quot;background-color: #999999;&quot;&gt;git commit -m “test submodule”&amp;&amp; git push&lt;/span&gt;</code></pre></li><li><p>此处<span style="color: #ff0000;">redlock</span>中已经变更为submodule<span style="color: #ff0000;">最新的commit id</span>.由原来的4066b307978ac81bf16e878aeb21210a5b794f06变更为717af34cae93e0d24dba04bbc166b8f1840f3893</p><p> <img src="/medias/images/submodule-7.png" alt=""></p></li></ul><h2 id="更新Submodule"><a href="#更新Submodule" class="headerlink" title="更新Submodule"></a><strong><strong>更新Submodule</strong></strong></h2><p>更新Submodule有两种方式:</p><ul><li><p>在父项目的目录下直接运行</p><pre><code> &lt;span style=&quot;background-color: #999999;&quot;&gt;git submodule foreach git pull&lt;/span&gt;</code></pre></li><li><p>在Submodule的目录下面更新(<span style="color: #ff0000;">推荐此操作</span>)</p><pre><code> &lt;span style=&quot;background-color: #999999;&quot;&gt;cd redlock &amp;&amp; git checkout (所要同步的commit id所在分支) &amp;&amp; git pull&lt;/span&gt;可以看到在Submodule的目录中,使用git和单独的一个项目是一样的,注意更新Submodule的时候如果有新的commit id产生，需要在父项目产生一个新的提交，git-Submodule文件中的 Submodule commit会变为最新的commit id。</code></pre></li></ul><h2 id="Clone-Submodule"><a href="#Clone-Submodule" class="headerlink" title="Clone Submodule"></a><strong><strong>Clone Submodule</strong></strong></h2><p>clone Submodule有两种方式 一种是采用<span style="color: #ff0000;">递归</span>的方式clone整个项目，一种是<span style="color: #ff0000;">clone父项目</span>，再<span style="color: #ff0000;">更新子项目</span></p><ul><li><p>采用递归参数–recursive</p><pre><code>&lt;span style=&quot;background-color: #999999;&quot;&gt; git clone git@github.com:DamonNie/git-Submodule.git --recursive&lt;/span&gt;</code></pre><p> <img src="/medias/images/submodule-8.png" alt=""></p><p> 这里一定要带上递归参数，否则init Submodule 的clone是不全的</p></li><li><p>第二种方法先clone父项目，再初始化Submodule</p><pre><code> &lt;span style=&quot;background-color: #999999;&quot;&gt;git clone git@github.com:damonnie/git-Submodule.git &amp;&amp; cd git-Submodule&lt;/span&gt;</code></pre></li><li><p>初始化submodule:</p><pre><code> &lt;span style=&quot;background-color: #999999;&quot;&gt;git submodule init&lt;/span&gt;</code></pre><p> <img src="/medias/images/submodule-9.png" alt=""></p></li><li><p>更新Submodule:</p><pre><code> &lt;span style=&quot;background-color: #999999;&quot;&gt;git submodule update&lt;/span&gt;</code></pre><p> <img src="/medias/images/submodule-10.png" alt=""></p><p>此处要注意:submodule文件都是<span style="color: #ff0000;">init状态</span>，如要获取最新，请<span style="color: #ff0000;">切换要同步的commit id所在分支</span>，并<span style="color: #ff0000;">git pull</span>操作</p><p><img src="/medias/images/submodule-11.png" alt=""></p><p><img src="/medias/images/submodule-12.png" alt=""></p></li></ul><h2 id="删除Submodule"><a href="#删除Submodule" class="headerlink" title="删除Submodule"></a><strong><strong>删除Submodule</strong></strong></h2><p><span style="color: #ff0000;">git 并不支持直接删除Submodule需要手动删除对应的文件</span> </p><ul><li><p>使用<span style="color: #ff0000;">vim .git/config</span> 可打开vim编辑,删除对应的内容</p></li><li><p>使用<span style="color: #ff0000;">rm -rf .git/modules/redlock</span>, 删除.git下的缓存模块，最后提交项目。</p></li><li><p>使用<span style="color: #ff0000;">git rm –cached redlock</span>将redlock从版本控制中删除（本地仍保留有），若不需要可不带 –cached进行完全删除</p><p> <img src="/medias/images/submodule-13.png" alt=""></p></li><li><p>使用<span style="color: #ff0000;">vim .gitmodules </span>可打开vim编辑,删除对应的内容</p><h2 id="遇见git-submodule的坑"><a href="#遇见git-submodule的坑" class="headerlink" title="遇见git submodule的坑"></a><strong><strong>遇见git submodule的坑</strong></strong></h2></li><li><p><span>切换分支的时候,终端突然出现这个问题 The following untracked working tree files would be overwritten by checkout。</span><br><img src="/medias/images/submodule-14.png" alt=""></p></li></ul><p>字面意思上理解就是，有git工具没有跟踪到的文件切换后会被覆盖。通过资料查询解决方法</p><pre><code>**解决办法：删除这些文件，再切换到对的分支上再拉取代码**  git clean -d -fx &quot;&quot;</code></pre><p>如若依然无法切换，删除git submodule对应控制的代码即可。</p><ul><li>使用git diff时候提示我:<br>```bash<br>diff –git a/fin-common-ultimate b/fin-common-ultimate</li></ul><p>— a/fin-common-ultimate<br>+++ b/fin-common-ultimate<br>@@ -1 +1 @@<br>-Subproject commit 0fdda668c6480ecb21eae7c6a8cd1357ff531d4b<br>+Subproject commit 0fdda668c6480ecb21eae7c6a8cd1357ff531d4b-dirty</p><pre><code>答：在git的1.7.0及更高版本中，如果子模块具有任何已修改的文件或未跟踪的文件，则它们被视为脏文件，而以前，只有子模块中的HEAD指向错误的提交时，情况才会如此。解决方案:&gt; 1、在返回父模块之前，提交或撤销子模块中的修改文件。可以使用一下命令撤销更改:```gitgit submodule foreach --recursive git checkout .</code></pre><blockquote><p>2、忽略”脏”的子模块</p></blockquote><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true"># 执行git命令:</span>git status --ignore-submodules=dirty<span class="token comment" spellcheck="true">#忽略任何子模块中的所有未跟踪文件</span>git config --global diff.ignoreSubmodules dirty<span class="token comment" spellcheck="true"># 添加--ignore-submodules到中git diff</span>[diff]  ignoreSubmodules = dirty</code></pre><p>这里我们使用第一种方案，撤销脏的子模块中的修改文件。更多详细请移步<a href="https://stackoverflow.com/questions/4873980/git-diff-says-subproject-is-dirty" target="_blank" rel="noopener">Git diff says subproject is dirty</a></p><p>参考: <u>姜家志:</u><a href="https://segmentfault.com/a/1190000003076028" target="_blank" rel="noopener"><u>使用Git Submodule管理子模块</u></a><u>唐巧的博客:</u><a href="https://blog.devtang.com/2013/05/08/git-submodule-issues/" target="_blank" rel="noopener"><u>Git submodule的坑</u></a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> git submodule </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js浮点数精度问题</title>
      <link href="/2018/12/09/js-fu-dian-shu-jing-du-wen-ti/"/>
      <url>/2018/12/09/js-fu-dian-shu-jing-du-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="JS中浮点数精度问题"><a href="#JS中浮点数精度问题" class="headerlink" title="JS中浮点数精度问题"></a>JS中浮点数精度问题</h1><p>  最近在做项目的时候，有遇到js的精度问题。在掘金上找了个比较完整的解决方案，特此深入学习了一些 收藏一下并分享给友友们。以下是方案解决内容:</p><h1 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h1><p>  总结了一下，一共有以下两种问题</p><h2 id="浮点数运算后的精度问题"><a href="#浮点数运算后的精度问题" class="headerlink" title="浮点数运算后的精度问题"></a>浮点数运算后的精度问题</h2><p>  在计算商品价格加减乘除时，偶尔## 会出现精度问题，一些常见的例子如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 加法 =====================</span><span class="token number">0.1</span> <span class="token operator">+</span><span class="token number">0.2</span> <span class="token operator">=</span><span class="token number">0.30000000000000004</span><span class="token number">0.7</span> <span class="token operator">+</span> <span class="token number">0.1</span> <span class="token operator">=</span><span class="token number">0.7999999999999999</span><span class="token number">0.2</span> <span class="token operator">+</span><span class="token number">0.4</span> <span class="token operator">=</span><span class="token number">0.6000000000000001</span><span class="token comment" spellcheck="true">// 减法 =====================</span><span class="token number">1.5</span> <span class="token operator">-</span><span class="token number">1.2</span> <span class="token operator">=</span><span class="token number">0.30000000000000004</span><span class="token number">0.3</span> <span class="token operator">-</span><span class="token number">0.2</span> <span class="token operator">=</span><span class="token number">0.09999999999999998</span><span class="token comment" spellcheck="true">// 乘法 =====================</span><span class="token number">19.9</span> <span class="token operator">*</span><span class="token number">100</span> <span class="token operator">=</span><span class="token number">1989.9999999999998</span><span class="token number">0.8</span> <span class="token operator">*</span><span class="token number">3</span> <span class="token operator">=</span><span class="token number">2.4000000000000004</span><span class="token number">35.41</span> <span class="token operator">*</span><span class="token number">100</span> <span class="token operator">=</span><span class="token number">3540.9999999999995</span><span class="token comment" spellcheck="true">// 除法 =====================</span><span class="token number">0.3</span> <span class="token operator">/</span> <span class="token number">0.1</span> <span class="token operator">=</span><span class="token number">2.9999999999999996</span><span class="token number">0.69</span> <span class="token operator">/</span><span class="token number">10</span> <span class="token operator">=</span><span class="token number">0.06899999999999999</span></code></pre><h2 id="toFixed奇葩问题"><a href="#toFixed奇葩问题" class="headerlink" title="toFixed奇葩问题"></a>toFixed奇葩问题</h2><p>  在遇到浮点数运算后出现的精度问题时，刚开始我是使用toFixed(2)来解决的，因为在W3school和菜鸟教程（他们均表示这锅不背）上明确写着定义：toFixed()方法可把Number四舍五入为指定小数位数的数字。<br>  但是在chrome下测试结果不太令人满意：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">1.35</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1.4 正确</span><span class="token number">1.335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1.33  错误</span><span class="token number">1.3335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1.333 错误</span><span class="token number">1.33335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1.3334 正确</span><span class="token number">1.333335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1.33333 错误</span><span class="token number">1.3333335</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1.333333 错误</span></code></pre><p>  使用IETester在IE下面测试的结果却是正确的。</p><h1 id="为什么会产生"><a href="#为什么会产生" class="headerlink" title="为什么会产生"></a>为什么会产生</h1><p>  让我们来看一下为什么0.1+0.2会等于0.30000000000000004，而不是0.3。首先，想要知道为什么会产生这样的问题，让我们回到大学里学的复（ku）杂（zao）的计算机组成原理。虽然已经全部还给大学老师了，但是没关系，我们还有百度嘛。</p><h2 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h2><p>  和其它语言如Java和Python不同，JavaScript中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用64位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。<br>  这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。<br>  64位比特又可分为三个部分：</p><p>*符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数<br>*指数位E：中间的 11 位存储指数（exponent），用来表示次方数<br>*尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/8/16205c88ea806bac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h2><p>  那么JavaScript在计算0.1+0.2时到底发生了什么呢？<br>  首先，十进制的0.1和0.2会被转换成二进制的，但是由于浮点数用二进制表示时是无穷的：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">0.1</span> <span class="token operator">-</span><span class="token operator">></span><span class="token number">0.0001100110011001</span><span class="token operator">...</span><span class="token punctuation">(</span><span class="token number">1100</span>循环<span class="token punctuation">)</span><span class="token number">0.2</span> <span class="token operator">-</span><span class="token operator">></span><span class="token number">0.0011001100110011</span><span class="token operator">...</span><span class="token punctuation">(</span><span class="token number">0011</span>循环<span class="token punctuation">)</span></code></pre><p>IEEE 754 标准的 64 位双精度浮点数的小数部分最多支持53位二进制位，所以两者相加之后得到二进制为：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">0.0100110011001100110011001100110011001100110011001100</span> </code></pre><p>  因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>  针对以上两个问题，网上搜了一波解决方法，基本都大同小异的，分别来看一下。</p><h2 id="解决toFixed"><a href="#解决toFixed" class="headerlink" title="解决toFixed"></a>解决toFixed</h2><p>  针对toFixed的兼容性问题，我们可以把toFix重写一下来解决，代码如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// toFixed兼容方法</span>Number<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toFixed <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">></span><span class="token number">20</span> <span class="token operator">||</span> len<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">thrownewRangeError</span><span class="token punctuation">(</span><span class="token string">"toFixed() digits argument must be between 0 and 20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// .123转为0.123</span><span class="token keyword">var</span> number <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token operator">||</span> number <span class="token operator">>=</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> number<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token string">"undefined"</span> <span class="token operator">||</span> len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">var</span> result <span class="token operator">=</span> number<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        numberArr <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>numberArr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//整数的情况</span><span class="token keyword">return</span> <span class="token function">padNum</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">var</span> intNum <span class="token operator">=</span> numberArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//整数部分</span>        deciNum <span class="token operator">=</span> numberArr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//小数部分</span>        lastNum <span class="token operator">=</span> deciNum<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最后一个数字</span><span class="token keyword">if</span><span class="token punctuation">(</span>deciNum<span class="token punctuation">.</span>length <span class="token operator">==</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//需要截取的长度等于当前长度</span><span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>deciNum<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//需要截取的长度大于当前长度 1.3.toFixed(2)</span><span class="token keyword">return</span> <span class="token function">padNum</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//需要截取的长度小于当前长度，需要判断最后一位数字</span>    result <span class="token operator">=</span> intNum <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> deciNum<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">parseInt</span><span class="token punctuation">(</span>lastNum<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//最后一位数字大于5，要进位</span>    <span class="token keyword">var</span> times <span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//需要放大的倍数</span>    <span class="token keyword">var</span> changedInt <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//截取后转为整数</span>        changedInt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//整数进位</span>        changedInt <span class="token operator">/</span><span class="token operator">=</span> times<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//整数转为小数，注：有可能还是整数</span>        result <span class="token operator">=</span> <span class="token function">padNum</span><span class="token punctuation">(</span>changedInt<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//对数字末尾加0</span><span class="token function">functionpadNum</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> dotPos <span class="token operator">=</span> num<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>dotPos <span class="token operator">===</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//整数的情况</span>            num <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"."</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                num <span class="token operator">+</span><span class="token operator">=</span><span class="token string">"0"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//小数的情况</span>        <span class="token keyword">var</span> need <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token punctuation">(</span>num<span class="token punctuation">.</span>length <span class="token operator">-</span> dotPos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>need<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                num <span class="token operator">+</span><span class="token operator">=</span><span class="token string">"0"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>  我们通过判断最后一位是否大于等于5来决定需不需要进位，如果需要进位先把小数乘以倍数变为整数，加1之后，再除以倍数变为小数，这样就不用一位一位的进行判断。</p><h2 id="解决浮点数运算精度"><a href="#解决浮点数运算精度" class="headerlink" title="解决浮点数运算精度"></a>解决浮点数运算精度</h2><p>  既然我们发现了浮点数的这个问题，又不能直接让两个浮点数运算，那怎么处理呢？<br>  我们可以把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完成后再进行降级（除以10的n次幂），这是大部分变成语言处理精度问题常用的方法。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">0.1</span> <span class="token operator">+</span><span class="token number">0.2</span> <span class="token operator">==</span> <span class="token number">0.3</span><span class="token comment" spellcheck="true">//false</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span><span class="token number">0.2</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0.3</span><span class="token comment" spellcheck="true">//true</span></code></pre><p>  但是这样就能完美解决么？细心的读者可能在上面的例子里已经发现了问题：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token number">35.41</span> <span class="token operator">*</span><span class="token number">100</span> <span class="token operator">=</span><span class="token number">3540.9999999999995</span></code></pre><p>  看来进行数字升级也不是完全的可靠啊（允悲）。<br>  但是魔高一尺道高一丈，这样就能难住我们么，我们可以将浮点数toString后indexOf(“.”)，记录一下小数位的长度，然后将小数点抹掉，完整的代码如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">/*** method ** *  add / subtract / multiply /divide * floatObj.add(0.1, 0.2) >> 0.3 * floatObj.multiply(19.9, 100) >> 1990 * */</span><span class="token keyword">var</span> floatObj <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*     * 判断obj是否为一个整数     */</span><span class="token function">functionisInteger</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">{</span>returnMath<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">===</span> obj    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*     * 将一个浮点数转成整数，返回整数和倍数。如 3.14 >> 314，倍数是 100     * @param floatNum {number} 小数     * @return {object}     *   {times:100, num: 314}     */</span><span class="token function">functiontoInteger</span><span class="token punctuation">(</span>floatNum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token punctuation">{</span>times<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isInteger</span><span class="token punctuation">(</span>floatNum<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ret<span class="token punctuation">.</span>num <span class="token operator">=</span> floatNum    <span class="token keyword">return</span> ret        <span class="token punctuation">}</span>    <span class="token keyword">var</span> strfi  <span class="token operator">=</span> floatNum <span class="token operator">+</span> <span class="token string">""</span>    <span class="token keyword">var</span> dotPos <span class="token operator">=</span> strfi<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> len    <span class="token operator">=</span> strfi<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>dotPos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length    <span class="token keyword">var</span> times  <span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span>    <span class="token keyword">var</span> intNum <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>floatNum<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        ret<span class="token punctuation">.</span>times  <span class="token operator">=</span> times        ret<span class="token punctuation">.</span>num    <span class="token operator">=</span> intNum<span class="token keyword">return</span> ret    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*     * 核心方法，实现加减乘除运算，确保不丢失精度     * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）     *     * @param a {number} 运算数1     * @param b {number} 运算数2     * @param digits {number} 精度，保留的小数点数，比如 2, 即保留为两位小数     * @param op {string} 运算类型，有加减乘除（add/subtract/multiply/divide）     *     */</span><span class="token function">functionoperation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">,</span> op<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token function">toInteger</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token function">toInteger</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token keyword">var</span> n1 <span class="token operator">=</span> o1<span class="token punctuation">.</span>num    <span class="token keyword">var</span> n2 <span class="token operator">=</span> o2<span class="token punctuation">.</span>num    <span class="token keyword">var</span> t1 <span class="token operator">=</span> o1<span class="token punctuation">.</span>times    <span class="token keyword">var</span> t2 <span class="token operator">=</span> o2<span class="token punctuation">.</span>times    <span class="token keyword">var</span> max <span class="token operator">=</span> t1 <span class="token operator">></span> t2 <span class="token operator">?</span> t1 <span class="token punctuation">:</span> t2    <span class="token keyword">var</span> result <span class="token operator">=</span><span class="token keyword">null</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span><span class="token string">"add"</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">===</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 两个小数位数相同</span>                    result <span class="token operator">=</span> n1 <span class="token operator">+</span> n2                <span class="token punctuation">}</span>elseif <span class="token punctuation">(</span>t1 <span class="token operator">></span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// o1 小数位 大于 o2</span>                    result <span class="token operator">=</span> n1 <span class="token operator">+</span> n2 <span class="token operator">*</span> <span class="token punctuation">(</span>t1 <span class="token operator">/</span> t2<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// o1 小数位 小于 o2</span>                    result <span class="token operator">=</span> n1 <span class="token operator">*</span> <span class="token punctuation">(</span>t2 <span class="token operator">/</span> t1<span class="token punctuation">)</span> <span class="token operator">+</span> n2                <span class="token punctuation">}</span>        <span class="token keyword">return</span> result <span class="token operator">/</span> max<span class="token keyword">case</span><span class="token string">"subtract"</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">===</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result <span class="token operator">=</span> n1 <span class="token operator">-</span> n2                <span class="token punctuation">}</span>elseif <span class="token punctuation">(</span>t1 <span class="token operator">></span> t2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result <span class="token operator">=</span> n1 <span class="token operator">-</span> n2 <span class="token operator">*</span> <span class="token punctuation">(</span>t1 <span class="token operator">/</span> t2<span class="token punctuation">)</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                    result <span class="token operator">=</span> n1 <span class="token operator">*</span> <span class="token punctuation">(</span>t2 <span class="token operator">/</span> t1<span class="token punctuation">)</span> <span class="token operator">-</span> n2                <span class="token punctuation">}</span>        <span class="token keyword">return</span> result <span class="token operator">/</span> max<span class="token keyword">case</span><span class="token string">"multiply"</span><span class="token punctuation">:</span>                result <span class="token operator">=</span> <span class="token punctuation">(</span>n1 <span class="token operator">*</span> n2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>t1 <span class="token operator">*</span> t2<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token keyword">case</span><span class="token string">"divide"</span><span class="token punctuation">:</span>                result <span class="token operator">=</span> <span class="token punctuation">(</span>n1 <span class="token operator">/</span> n2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>t2 <span class="token operator">/</span> t1<span class="token punctuation">)</span>        <span class="token keyword">return</span> result        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 加减乘除的四个接口</span><span class="token function">functionadd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">,</span><span class="token string">"add"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token function">functionsubtract</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">,</span><span class="token string">"subtract"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token function">functionmultiply</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">,</span><span class="token string">"multiply"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token function">functiondivide</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">operation</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> digits<span class="token punctuation">,</span><span class="token string">"divide"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// exports</span><span class="token keyword">return</span> <span class="token punctuation">{</span>add<span class="token punctuation">:</span> add<span class="token punctuation">,</span>subtract<span class="token punctuation">:</span> subtract<span class="token punctuation">,</span>multiply<span class="token punctuation">:</span> multiply<span class="token punctuation">,</span>divide<span class="token punctuation">:</span> divide    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果觉得floatObj调用麻烦，我们可以在Number.prototype上添加对应的运算方法。<br>参考：<a href="https://juejin.im/post/5aa1395c6fb9a028df223516" target="_blank" rel="noopener">谢小飞的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细数平时工作中用到的git命令</title>
      <link href="/2018/12/06/git/"/>
      <url>/2018/12/06/git/</url>
      
        <content type="html"><![CDATA[<h2 id="git基本操作命令"><a href="#git基本操作命令" class="headerlink" title="git基本操作命令"></a><strong>git基本操作命令</strong></h2><h3 id="添加git仓库"><a href="#添加git仓库" class="headerlink" title="添加git仓库"></a>添加git仓库</h3><pre class=" language-html"><code class="language-html">git initgit remote add origin <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>origin地址</span><span class="token punctuation">></span></span></code></pre><p>或者</p><pre class=" language-html"><code class="language-html">git clone <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>origin地址</span><span class="token punctuation">></span></span></code></pre><h3 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h3><blockquote><p>查看分支列表</p></blockquote><pre class=" language-html"><code class="language-html">git branch -a</code></pre><blockquote><p>创建新分支</p></blockquote><pre class=" language-html"><code class="language-html">git branch <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>branch名称</span><span class="token punctuation">></span></span></code></pre><blockquote><p>切换分支</p></blockquote><pre class=" language-html"><code class="language-html">git check <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>branch名称</span><span class="token punctuation">></span></span></code></pre><p>然后，上面两个命令也可以合成为一个命令</p><pre class=" language-html"><code class="language-html">git checkout -b <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>branch名称</span><span class="token punctuation">></span></span> ,</code></pre><p>这里经常有使用到git checkout -b origin &lt;branch名称&gt;，创建本地分支并拉取远程到本地</p><h3 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h3><blockquote><p>查看仓库有变化文件</p></blockquote><pre class=" language-html"><code class="language-html">git status</code></pre><blockquote><p>添加文件到索引库</p></blockquote><pre class=" language-html"><code class="language-html">git add <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file带路径的名称</span><span class="token punctuation">></span></span></code></pre><p>这里使用git add .,提交当前库中有变化的文件到索引库中</p><blockquote><p>提交added状态的文件，即添加到索引库中的文件</p></blockquote><pre class=" language-html"><code class="language-html">git commit -m '<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>注释</span><span class="token punctuation">></span></span>'</code></pre><blockquote><p>提交远程仓库</p></blockquote><pre class=" language-html"><code class="language-html">git push origin <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>branch名称</span><span class="token punctuation">></span></span></code></pre><p>这里如果当前分支只有一个追踪分支，git push即可。远程主机名可以忽略</p><blockquote><p>拉取分支更新文件</p></blockquote><pre class=" language-html"><code class="language-html">git pull origin <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>branch名称</span><span class="token punctuation">></span></span></code></pre><p>如果当前分支与主机存在追踪关系，git pull origin即可。如果只有一个追踪分支，远程主机名忽略 git pull即可</p><blockquote><p>删除分支</p></blockquote><pre class=" language-html"><code class="language-html">git branch -d <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>branch名称</span><span class="token punctuation">></span></span></code></pre><p>如若要删除远程分支，git push –delete origin &lt;branch名称&gt;</p><h3 id="git合并"><a href="#git合并" class="headerlink" title="git合并"></a>git合并</h3><blockquote><p>合并分支<br>示例一:将分支master合并到当前分支中，但不要自动进行新的提交</p></blockquote><pre class=" language-html"><code class="language-html">git merge --no-commit master</code></pre><p>示例二:合并到当前分支中，保留分支提交记录不自动提交</p><pre class=" language-html"><code class="language-html">git merge --no-ff master</code></pre><p>示例三:合并到当期分支,自动进行提交</p><pre class=" language-html"><code class="language-html">git merge master</code></pre><blockquote><p>合并冲突解决</p></blockquote><pre class=" language-html"><code class="language-html">setp1:更新并拉取远程到本地git fetch origingit checkout -b origin/masterstep2:切换拉取远程需被合并的分支，如已切换作pull操作git checkout -b origin <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>branch名称</span><span class="token punctuation">></span></span>step3:示例二操作，合并master到当前分支 不提交git merge --no-ff masterstep4:推送到远程主机git push origin <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>branch名称</span><span class="token punctuation">></span></span></code></pre><h3 id="git小知识"><a href="#git小知识" class="headerlink" title="git小知识"></a>git小知识</h3><blockquote><p>查看日志提交记录</p></blockquote><pre class=" language-html"><code class="language-html">git log</code></pre><blockquote><p>还在工作区，并未进入暂存区可以执行撤销操作</p></blockquote><pre class=" language-html"><code class="language-html">>git checkout .>git reset --hard</code></pre><blockquote><p>查看尚未暂存的文件更新了哪些部分</p></blockquote><pre class=" language-html"><code class="language-html">git diff <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>带路径的file</span><span class="token punctuation">></span></span></code></pre><blockquote><p>查看暂存区和本地仓库之间的差异</p></blockquote><pre class=" language-html"><code class="language-html">git diff --cached</code></pre><blockquote><p>删除文件</p></blockquote><pre class=" language-html"><code class="language-html">git rm -r <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>带路径的file</span><span class="token punctuation">></span></span></code></pre><blockquote><p>查看当前本地分支与远程分支的关联</p></blockquote><pre class=" language-html"><code class="language-html">git branch -v</code></pre><blockquote><p>标签</p></blockquote><pre class=" language-html"><code class="language-html">git tag </code></pre><p>创建标签则带参数-a，git tag -a &lt;tag名称&gt;</p><blockquote><p>git pull 或者git push有时候会出现此提示</p></blockquote><pre class=" language-bash"><code class="language-bash">There is no tracking information <span class="token keyword">for</span> the current branch.Please specify <span class="token function">which</span> branch you want to merge with.See git-pull<span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token keyword">for</span> details.    <span class="token function">git</span> pull <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token operator">&lt;</span>branch<span class="token operator">></span>If you wish to <span class="token keyword">set</span> tracking information <span class="token keyword">for</span> this branch you can <span class="token keyword">do</span> so with:    <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/<span class="token operator">&lt;</span>branch<span class="token operator">></span> master</code></pre><p>done:</p><pre class=" language-git"><code class="language-git">git branch --set-upstream-to=origin/&lt;远程分支名字></code></pre><blockquote><p>git 回滚到之前某提交commit-id</p></blockquote><pre><code>git reset --hard commit-id :回滚到commit-id，讲commit-id之后提交的commit都去除git reset --hard HEAD~3：将最近3次的提交回滚</code></pre><h2 id="git进阶篇"><a href="#git进阶篇" class="headerlink" title="git进阶篇"></a>git进阶篇</h2><p><a href="https://github.com/DamonNie/git-Submodule" target="_blank" rel="noopener">git子模块</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客主题之hexo-theme-matery的介绍</title>
      <link href="/2018/09/28/hexo/"/>
      <url>/2018/09/28/hexo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一个采用<code>Material Design</code>和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 博客了。如果还没有的话，不妨使用 Hexo 和 <a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a> 来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/damonnie/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>Git clone</code> 命令来下载:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/damonnie/hexo-theme-matery.git</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> categories<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"categories"</span><span class="token punctuation">---</span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> tags<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 18:23:38</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"tags"</span><span class="token punctuation">---</span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"about"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> about<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-30 17:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"about"</span><span class="token punctuation">---</span></code></pre><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class=" language-bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> friends<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-12-12 21:25:30</span><span class="token key atrule">type</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token key atrule">layout</span><span class="token punctuation">:</span> <span class="token string">"friends"</span><span class="token punctuation">---</span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"ttps://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prism_plugin</span><span class="token punctuation">:</span>  <span class="token key atrule">mode</span><span class="token punctuation">:</span> <span class="token string">'preprocess'</span>    <span class="token comment" spellcheck="true"># realtime/preprocess</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> <span class="token string">'tomorrow'</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">false    </span><span class="token comment" spellcheck="true"># default false</span>  custom_css<span class="token punctuation">:</span></code></pre><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post</code></pre><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment" spellcheck="true"># default: '-'</span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feed</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> atom  <span class="token key atrule">path</span><span class="token punctuation">:</span> atom.xml  <span class="token key atrule">limit</span><span class="token punctuation">:</span> <span class="token number">20</span>  <span class="token key atrule">hub</span><span class="token punctuation">:</span>  <span class="token key atrule">content</span><span class="token punctuation">:</span>  <span class="token key atrule">content_limit</span><span class="token punctuation">:</span> <span class="token number">140</span>  <span class="token key atrule">content_limit_delim</span><span class="token punctuation">:</span> <span class="token string">' '</span>  <span class="token key atrule">order_by</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://github.com/damonnie<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-github<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>4.7.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"五月雨变奏电音"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"AnimeVibe"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music1.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover1.png"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Take me hand"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"DAISHI DANCE,Cecile Corbel"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"/medias/music/music2.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"/medias/music/cover2.png"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Shape of You"</span><span class="token punctuation">,</span>    <span class="token property">"artist"</span><span class="token operator">:</span> <span class="token string">"J.Fla"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music3.mp3"</span><span class="token punctuation">,</span>    <span class="token property">"cover"</span><span class="token operator">:</span> <span class="token string">"http://xxx.com/music-cover3.png"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><blockquote><p><strong>注</strong>：以上 JSON 中的属性：<code>name</code>、<code>artist</code>、<code>url</code>、<code>cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。</p></blockquote><p>然后，在主题的 <code>_config.yml</code> 配置文件中激活配置即可：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 是否在首页显示音乐.</span><span class="token key atrule">music</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">showTitle</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">title</span><span class="token punctuation">:</span> 听听音乐  <span class="token key atrule">fixed</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 是否开启吸底模式</span>  <span class="token key atrule">autoplay</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 是否自动播放</span>  <span class="token key atrule">theme</span><span class="token punctuation">:</span> '<span class="token comment" spellcheck="true">#42b983'</span>  <span class="token key atrule">loop</span><span class="token punctuation">:</span> <span class="token string">'all'</span> <span class="token comment" spellcheck="true"># 音频循环播放, 可选值: 'all', 'one', 'none'</span>  <span class="token key atrule">order</span><span class="token punctuation">:</span> <span class="token string">'list'</span> <span class="token comment" spellcheck="true"># 音频循环顺序, 可选值: 'list', 'random'</span>  <span class="token key atrule">preload</span><span class="token punctuation">:</span> <span class="token string">'auto'</span> <span class="token comment" spellcheck="true"># 预加载，可选值: 'none', 'metadata', 'auto'</span>  <span class="token key atrule">volume</span><span class="token punctuation">:</span> <span class="token number">0.7 </span><span class="token comment" spellcheck="true"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span>  <span class="token key atrule">listFolded</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 列表默认折叠</span>  <span class="token key atrule">listMaxHeight</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 列表最大高度</span></code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /medias/images/1.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /medias/images/2.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h3 id="添加萌萌的动漫人物"><a href="#添加萌萌的动漫人物" class="headerlink" title="添加萌萌的动漫人物"></a>添加萌萌的动漫人物</h3><p>先看看添加卡通人物之后的效果：</p><p>安装插件</p><pre class=" language-npm"><code class="language-npm">复制代码```安装下载动画人物库 如：```npm install live2d-widget-model-z16 -D</code></pre><p>根目录_config.yml配置里面添加：</p><pre class=" language-live2d:"><code class="language-live2d:">  enable:true   scriptFrom: local   pluginRootPath: live2dw/   pluginJsPath: lib/   pluginModelPath: assets/   tagMode:false   log:false   model:     use: live2d-widget-model-z16   display:     position: right     width:150     height:300   mobile:     show:true     react:       opacity:0.7</code></pre><p>动画库的样式示例：<br>Epsilon2.1</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/18/16d432179164a4f1?imageslim" alt=""></p><p>Gantzert_Felixander：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/18/16d432179bcce33f?imageslim" alt=""><br>ni-j：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/18/16d4321812725510?imageslim" alt=""><br>nico：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/18/16d43218304b10d6?imageslim" alt=""><br>shizuku：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/18/16d43217e3c25e0a?imageslim" alt=""><br>z16：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/18/16d43217e471c240?imageslim" alt=""><br>动漫人物只好不要和不蒜子一起使用，不然不蒜子会显示不出来。</p><h3 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h3><p>原来的主题没有404页面，首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span>title<span class="token punctuation">:</span><span class="token number">404</span>date<span class="token punctuation">:</span>2017<span class="token punctuation">-</span>07<span class="token punctuation">-</span>1916<span class="token punctuation">:</span><span class="token datetime number">41:10</span>type<span class="token punctuation">:</span><span class="token string">"404"</span>layout<span class="token punctuation">:</span><span class="token string">"404"</span>description<span class="token punctuation">:</span><span class="token string">"你访问的页面被外星人叼走了 :("</span><span class="token punctuation">---</span></code></pre><p>/themes/matery/layout/<code>目录下新建一个</code>404.ejs`文件，内容如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>style type<span class="token operator">=</span><span class="token string">"text/css"</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">/* don't remove. */</span>  <span class="token punctuation">.</span>about<span class="token operator">-</span>cover <span class="token punctuation">{</span>          height<span class="token punctuation">:</span> 75vh<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"bg-cover pd-header about-cover"</span><span class="token operator">></span>  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"container"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"row"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"col s10 offset-s1 m8 offset-m2 l8 offset-l2"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"brand"</span><span class="token operator">></span>          <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"title center-align"</span><span class="token operator">></span>            <span class="token number">404</span>          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>          <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"description center-align"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">%</span><span class="token operator">=</span> page<span class="token punctuation">.</span>description <span class="token operator">%</span><span class="token operator">></span>          <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span>  <span class="token comment" spellcheck="true">// 每天切换 banner 图.  Switch banner image every day.</span>      <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>效果如下：<br> <img src="https://user-gold-cdn.xitu.io/2019/9/18/16d43217a18fcfc6?imageView2/0/w/1280/h/960/ignore-error/1" alt="效果图"></p><p>引用并感谢:<a href="https://blinkfox.github.io/" target="_blank" rel="noopener">闪烁之狐</a> <a href="https://gongchenghuigch.github.io/2019/09/09/theme/" target="_blank" rel="noopener">浅夏晴空</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
